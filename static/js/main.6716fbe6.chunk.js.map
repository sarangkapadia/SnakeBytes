{"version":3,"sources":["grid.ts","title.tsx","score.tsx","button.tsx","snake.ts","box.tsx","gridRenderer.tsx","debug/debugBox.tsx","debug/debugGrid.tsx","gridContainer.tsx","useInterval.tsx","App.tsx","index.tsx"],"names":["Direction","Role","Title","Score","React","memo","props","currentScore","Button","className","onClick","label","Snake","snakeEnds","this","tail","row","col","head","GridItem","role","Canvas","direction","None","Grid","grid","gridSize","snake","root","document","querySelector","rootStyle","getComputedStyle","parseInt","getPropertyValue","Array","i","j","getSnakeEnds","Tail","Head","Body","Error","Box","currentHeadDirection","getClassNameFromDirection","dir","Down","Up","Left","Right","Byte","getClassName","GridRenderer","flat","map","item","index","id","getStringRole","getStringDirection","DebugBox","DebugGrid","url","URL","window","location","href","urlSearchParams","URLSearchParams","search","gridObj","initGridData","getGridSize","getGrid","currentHeadDir","getCurrentHeadDirection","currentTailDir","getCurrentTailDirection","GridContainer","useState","getSnake","setSnakeEnds","playing","setPlaying","debug","setDebug","handlers","useSwipeable","onSwipedLeft","onSwipedRight","onSwipedDown","onSwipedUp","preventDefaultTouchmoveEvent","trackMouse","callback","delay","savedCallback","useRef","useLayoutEffect","current","useEffect","setInterval","clearInterval","useInterval","ends","newCol","newRow","getNewEnds","handleOnPlayPauseGame","useCallback","handleOnDebug","get","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6716fbe6.chunk.js","sourcesContent":["import { Snake } from \"./snake\";\n\nexport enum Direction {\n  None,\n  Up,\n  Down,\n  Right,\n  Left,\n}\n\nexport enum Role {\n  Canvas,\n  Body,\n  Head,\n  Tail,\n  Byte,\n}\n\nexport interface IGridItem {\n  role: Role;\n  direction: Direction;\n}\n\nclass GridItem implements IGridItem {\n  role = Role.Canvas;\n  direction = Direction.None;\n}\n\nexport class Grid {\n  private grid: GridItem[][];\n  private gridSize: number;\n  private snake: Snake; // Grid contains a Snake\n\n  public constructor() {\n    const root = document.querySelector(\":root\")!;\n    const rootStyle = getComputedStyle(root);\n    this.gridSize = parseInt(rootStyle.getPropertyValue(\"--gridSize\"));\n\n    this.grid = new Array(this.gridSize);\n    for (let i = 0; i < this.gridSize; i++) {\n      this.grid[i] = new Array(this.gridSize);\n    }\n\n    for (let i = 0; i < this.gridSize; i++) {\n      for (let j = 0; j < this.gridSize; j++) {\n        this.grid[i][j] = new GridItem();\n      }\n    }\n\n    this.snake = new Snake();\n  }\n\n  public getGrid(): GridItem[][] {\n    return this.grid;\n  }\n\n  public getGridSize(): number {\n    return this.gridSize;\n  }\n\n  public getSnake(): Snake {\n    return this.snake;\n  }\n\n  public getCurrentHeadDirection(): Direction {\n    const { head } = this.snake.getSnakeEnds();\n    return this.grid[head.row][head.col].direction;\n  }\n\n  public getCurrentTailDirection(): Direction {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].direction;\n  }\n\n  public initGridData() {\n    const { tail, head } = this.snake.getSnakeEnds();\n\n    this.grid[tail.row][tail.col].direction = Direction.None;\n    this.grid[head.row][head.col].direction = Direction.None;\n\n    this.grid[tail.row][tail.col].role = Role.Tail;\n    this.grid[head.row][head.col].role = Role.Head;\n\n    if (tail.row === head.row) {\n      // horizontal snake\n      for (let i = tail.col + 1; i < head.col; i++) {\n        this.grid[tail.row][i].role = Role.Body;\n        this.grid[head.row][i].role = Role.Body;\n      }\n    } else if (tail.col === head.col) {\n      // vertical snake\n      for (let i = tail.row + 1; i < head.row; i++) {\n        this.grid[i][tail.col].role = Role.Body;\n        this.grid[i][tail.col].role = Role.Body;\n      }\n    } else {\n      throw new Error(\"Snake init invalid\");\n    }\n  }\n}\n","import React from \"react\";\n\nexport const Title: React.FunctionComponent = () => {\n  return <h2>SNAKE</h2>;\n};\n","import React from 'react';\n\ninterface IScoreProps{\n    currentScore:number;\n}\nexport const Score: React.FunctionComponent<IScoreProps> = React.memo((props) => {\n    return <h2>Score: {props.currentScore}</h2>\n});","import React from \"react\";\nimport \"./style/button.css\";\n\ninterface IButtonProps {\n  onClick: () => void;\n  label: string;\n}\n\nexport const Button: React.FunctionComponent<IButtonProps> = React.memo(\n  (props) => {\n    return (\n      <button className={\"newGame\"} onClick={props.onClick}>\n        {props.label}\n      </button>\n    );\n  }\n);\n","// Snake metadata\n\nexport interface ISnakeEnds {\n  tail: { row: number; col: number };\n  head: { row: number; col: number };\n}\n\nexport class Snake {\n  private snakeEnds: ISnakeEnds;\n\n  public constructor(snakeEnds?: ISnakeEnds) {\n    if (snakeEnds) {\n      this.snakeEnds = snakeEnds;\n      return;\n    }\n\n    this.snakeEnds = {\n      tail: { row: 5, col: 5 },\n      head: { row: 8, col: 5 },\n    };\n  }\n\n  public getSnakeEnds(): ISnakeEnds {\n    return this.snakeEnds;\n  }\n\n  public setSnakeEnds(snakeEnds: ISnakeEnds): void {\n    this.snakeEnds = snakeEnds;\n  }\n\n  public snakeAlive(): boolean {\n    // TBD check if the snake head is not collided with a body/tail\n    return true;\n  }\n\n  public snakeLength(): number {\n    // TBD - return the number of grid locations\n    return 4;\n  }\n}\n","import React from \"react\";\nimport { Direction, Role } from \"./grid\";\nimport \"./style/box.css\";\n\ninterface IBoxProps {\n  id: number;\n  role: Role;\n  currentHeadDirection: Direction;\n}\n\nexport const Box: React.FunctionComponent<IBoxProps> = React.memo((props) => {\n  const { role, currentHeadDirection } = props;\n\n  const getClassNameFromDirection = (dir: Direction) => {\n    switch (dir) {\n      case Direction.Down:\n        return \"t2b\";\n      case Direction.Up:\n        return \"b2t\";\n      case Direction.Left:\n        return \"r2l\";\n      case Direction.Right:\n        return \"l2r\";\n      case Direction.None:\n        return \"none\";\n      default:\n        throw new Error(\"invalid dir\");\n    }\n  };\n\n  const getClassName = (): string => {\n    switch (role) {\n      case Role.Canvas:\n        return \"box\";\n      case Role.Head:\n        return `head_${getClassNameFromDirection(currentHeadDirection)}`;\n      case Role.Body:\n        return \"snake\";\n      case Role.Tail:\n        return `tail_${getClassNameFromDirection(currentHeadDirection)}`; // fix this to tail\n      case Role.Byte:\n        return \"food\";\n      default:\n        throw new Error(\"invalid role\");\n    }\n  };\n\n  let className = getClassName();\n\n  return <div className={className}></div>;\n});\n","import React from \"react\";\nimport { Box } from \"./box\";\nimport { Direction, IGridItem } from \"./grid\";\nimport \"./style/grid.css\";\n\ninterface IGridRendererProps {\n  grid: IGridItem[][];\n  currentHeadDirection: Direction;\n}\n\nexport const GridRenderer: React.FunctionComponent<IGridRendererProps> = (\n  props\n) => {\n  const { grid, currentHeadDirection } = props;\n\n  return (\n    <div className={\"grid\"}>\n      {grid.flat().map((item, index) => (\n        <Box\n          role={item.role}\n          id={index}\n          key={index}\n          currentHeadDirection={currentHeadDirection}\n        />\n      ))}\n    </div>\n  );\n};\n","import { IGridItem, Role, Direction } from \"../grid\";\nimport \"../style/debug/debugBox.css\";\n\nconst getStringRole = (role: Role): string => {\n  switch (role) {\n    case Role.Body:\n      return \"b\";\n    case Role.Head:\n      return \"h\";\n    case Role.Tail:\n      return \"t\";\n    case Role.Canvas:\n      return \"c\";\n    case Role.Byte:\n      return \"f\";\n    default:\n      throw new Error(\"invalid role\");\n  }\n};\n\nconst getStringDirection = (direction: Direction): string => {\n  switch (direction) {\n    case Direction.Down:\n      return \"d\";\n    case Direction.Up:\n      return \"u\";\n    case Direction.Left:\n      return \"l\";\n    case Direction.Right:\n      return \"r\";\n    case Direction.None:\n      return \"n\";\n    default:\n      throw new Error(\"invalid direction\");\n  }\n};\n\nexport const DebugBox: React.FunctionComponent<IGridItem> = (props) => {\n  const { role, direction } = props;\n  return (\n    <div className={\"debugBox\"}>\n      <ul>\n        {role > 0 ? <li>{getStringRole(role)}</li> : null}\n        {direction > 0 ? <li>{getStringDirection(direction)}</li> : null}\n      </ul>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { DebugBox } from \"./debugBox\";\nimport { IGridItem } from \"../grid\";\n\nimport \"../style/debug/debugGrid.css\";\n\ninterface IDebugGridProps {\n  grid: IGridItem[][];\n}\n\nexport const DebugGrid: React.FunctionComponent<IDebugGridProps> = (props) => {\n  const { grid } = props;\n  return (\n    <div className={\"debugGrid\"}>\n      {grid.flat().map((item, index) => (\n        <DebugBox key={index} role={item.role} direction={item.direction} />\n      ))}\n    </div>\n  );\n};\n","import React, { useCallback, useState } from \"react\";\nimport { Score } from \"./score\";\nimport { Button } from \"./button\";\nimport { useInterval } from \"./useInterval\";\nimport { GridRenderer } from \"./gridRenderer\";\nimport { useSwipeable } from \"react-swipeable\";\nimport { Grid, Direction, Role } from \"./grid\";\nimport { DebugGrid } from \"./debug/debugGrid\";\n\nconst url: URL = new URL(window.location.href);\nconst urlSearchParams = new URLSearchParams(url.search);\n\nconst gridObj = new Grid();\ngridObj.initGridData();\n\nconst gridSize = gridObj.getGridSize();\nconst grid = gridObj.getGrid();\n\nlet currentHeadDir = gridObj.getCurrentHeadDirection();\nlet currentTailDir = gridObj.getCurrentTailDirection();\n\nexport const GridContainer: React.FunctionComponent = () => {\n  const [snakeEnds, setSnakeEnds] = useState(gridObj.getSnake().getSnakeEnds());\n  const [playing, setPlaying] = useState(false);\n  const [debug, setDebug] = useState(false);\n\n  // add logic in these to detect game end\n  const onSwipedLeft = () => {\n    if (!playing) return;\n    currentHeadDir = Direction.Left;\n  };\n  const onSwipedRight = () => {\n    if (!playing) return;\n    currentHeadDir = Direction.Right;\n  };\n  const onSwipedUp = () => {\n    if (!playing) return;\n    currentHeadDir = Direction.Up;\n  };\n  const onSwipedDown = () => {\n    if (!playing) return;\n    currentHeadDir = Direction.Down;\n  };\n\n  const handlers = useSwipeable({\n    onSwipedLeft: onSwipedLeft,\n    onSwipedRight: onSwipedRight,\n    onSwipedDown: onSwipedDown,\n    onSwipedUp: onSwipedUp,\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: true,\n  });\n\n  const getNewEnds = (ends: typeof snakeEnds) => {\n    let newCol = snakeEnds.head.col;\n    let newRow = snakeEnds.head.row;\n    grid[newRow][newCol].role = Role.Body; // make current head -> snake\n\n    switch (currentHeadDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.head.row - 1 < 0 ? gridSize - 1 : snakeEnds.head.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.head.row + 1 >= gridSize ? 0 : snakeEnds.head.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.head.col + 1 >= gridSize ? 0 : snakeEnds.head.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.head.col - 1 < 0 ? gridSize - 1 : snakeEnds.head.col - 1;\n        break;\n      }\n      default:\n        throw new Error(\"Invalid head direction!\");\n    }\n    ends.head.row = newRow;\n    ends.head.col = newCol;\n\n    grid[newRow][newCol].role = Role.Head; // b -> h\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].role = Role.Canvas; // t -> b\n\n    newCol = snakeEnds.tail.col;\n    newRow = snakeEnds.tail.row;\n\n    switch (currentTailDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.tail.row - 1 < 0 ? gridSize - 1 : snakeEnds.tail.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.tail.row + 1 >= gridSize ? 0 : snakeEnds.tail.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.tail.col + 1 >= gridSize ? 0 : snakeEnds.tail.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.tail.col - 1 < 0 ? gridSize - 1 : snakeEnds.tail.col - 1;\n        break;\n      }\n      default:\n        throw new Error(\"Invalid tail direction!\");\n    }\n\n    ends.tail.row = newRow;\n    ends.tail.col = newCol;\n    grid[newRow][newCol].role = Role.Tail; // s -> t\n\n    return ends;\n  };\n\n  const onTick = () => {\n    let ends = { ...snakeEnds };\n    setSnakeEnds(getNewEnds(ends));\n  };\n\n  useInterval(\n    onTick,\n    // Delay in milliseconds or null to stop it\n    playing ? 600 : null\n  );\n\n  const handleOnPlayPauseGame = useCallback(() => {\n    if (!playing) {\n      // on hitting play\n      if (\n        currentHeadDir === Direction.None &&\n        currentTailDir === Direction.None\n      ) {\n        currentTailDir = Direction.Down;\n        currentHeadDir = Direction.Down;\n      }\n    }\n\n    setPlaying((playing) => !playing);\n  }, [playing]);\n\n  const handleOnDebug = useCallback(() => {\n    setDebug((debug) => !debug);\n  }, []);\n\n  const isDebugMode = () => {\n    return urlSearchParams.get(\"debug\") === \"true\";\n  };\n\n  return (\n    <div {...handlers}>\n      {debug ? (\n        <DebugGrid grid={grid} />\n      ) : (\n        <GridRenderer grid={grid} currentHeadDirection={currentHeadDir} />\n      )}\n      <div className={\"appUtils\"}>\n        <Score currentScore={0}></Score>\n        <Button\n          onClick={handleOnPlayPauseGame}\n          label={playing ? \"Pause\" : \"Play\"}\n        />\n        {isDebugMode() ? (\n          <Button\n            onClick={handleOnDebug}\n            label={debug ? \"Debug Off\" : \"Debug On\"}\n          />\n        ) : null}\n      </div>\n    </div>\n  );\n};\n","import { useEffect, useLayoutEffect, useRef } from \"react\"\n\nexport const useInterval = (callback: () => void, delay: number | null) => {\n    const savedCallback = useRef(callback)\n  \n    // Remember the latest callback if it changes.\n    useLayoutEffect(() => {\n      savedCallback.current = callback\n    }, [callback])\n  \n    // Set up the interval.\n    useEffect(() => {\n      // Don't schedule if no delay is specified.\n      if (!delay) {\n        return\n      }\n  \n      const id = setInterval(() => savedCallback.current(), delay)\n  \n      return () => clearInterval(id)\n    }, [delay])\n  }","import React from \"react\";\nimport \"./style/App.css\";\n\nimport { Title } from \"./title\";\nimport { GridContainer } from \"./gridContainer\";\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <div className={\"appContainer\"}>\n      <Title />\n      <GridContainer />\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/index.css\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}