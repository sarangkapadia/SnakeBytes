{"version":3,"sources":["grid.ts","button.tsx","snake.ts","box.tsx","gridRenderer.tsx","debug/debugBox.tsx","debug/debugGrid.tsx","wordtiles.tsx","gridContainer.tsx","useInterval.tsx","title.tsx","header.tsx","App.tsx","index.tsx"],"names":["Direction","Role","Button","React","memo","props","className","onClick","label","Snake","snakeEnds","this","tail","row","col","head","GridItem","role","Canvas","direction","None","Grid","grid","gridSize","snake","root","document","querySelector","rootStyle","getComputedStyle","parseInt","getPropertyValue","Array","i","j","getSnakeEnds","Tail","Head","Body","Error","Box","currentHeadDirection","getClassNameFromDirection","dir","Down","Up","Left","Right","Byte","getClassName","GridRenderer","flat","map","item","index","id","getStringRole","getStringDirection","DebugBox","DebugGrid","WordTiles","tickCount","tickCountMs","parseFloat","substr","length","url","URL","window","location","href","urlSearchParams","URLSearchParams","search","gridObj","initGridData","getGridSize","getGrid","GridContainer","useState","getSnake","setSnakeEnds","playing","setPlaying","debug","setDebug","handlers","useSwipeable","onSwipedLeft","currentHeadDir","getCurrentHeadDirection","console","log","setCurrentHeadDirection","onSwipedRight","onSwipedDown","onSwipedUp","preventDefaultTouchmoveEvent","trackMouse","callback","delay","savedCallback","useRef","useLayoutEffect","current","useEffect","setInterval","clearInterval","useInterval","newEnds","ends","newCol","newRow","currentTailDir","getCurrentTailDirection","getNewEnds","handleOnPlayPauseGame","useCallback","setCurrentTailDirection","handleOnDebug","get","Title","Header","style","margin","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"ySAEYA,EAQAC,E,2ECFCC,EAAgDC,IAAMC,MACjE,SAACC,GACC,OACE,wBAAQC,UAAW,UAAWC,QAASF,EAAME,QAA7C,SACGF,EAAMG,W,cCLFC,EAAb,WAGE,WAAmBC,GAAyB,yBAFpCA,eAEmC,EAEvCC,KAAKD,UADHA,GAKa,CACfE,KAAM,CAAEC,IAAK,EAAGC,IAAK,GACrBC,KAAM,CAAEF,IAAK,EAAGC,IAAK,IAX3B,gDAeE,WACE,OAAOH,KAAKD,YAhBhB,0BAmBE,SAAoBA,GAClBC,KAAKD,UAAYA,IApBrB,wBAuBE,WAEE,OAAO,IAzBX,yBA4BE,WAEE,OAAO,MA9BX,M,SFLYV,O,eAAAA,I,WAAAA,I,eAAAA,I,iBAAAA,I,gBAAAA,M,cAQAC,O,mBAAAA,I,eAAAA,I,eAAAA,I,eAAAA,I,gBAAAA,M,SAaNe,E,mDACJC,KAAOhB,EAAKiB,O,KACZC,UAAYnB,EAAUoB,QAGXC,EAAb,WAKE,aAAsB,yBAJdC,UAIa,OAHbC,cAGa,OAFbC,WAEa,EACnB,IAAMC,EAAOC,SAASC,cAAc,SAC9BC,EAAYC,iBAAiBJ,GACnCd,KAAKY,SAAWO,SAASF,EAAUG,iBAAiB,eAEpDpB,KAAKW,KAAO,IAAIU,MAAMrB,KAAKY,UAC3B,IAAK,IAAIU,EAAI,EAAGA,EAAItB,KAAKY,SAAUU,IACjCtB,KAAKW,KAAKW,GAAK,IAAID,MAAMrB,KAAKY,UAGhC,IAAK,IAAIU,EAAI,EAAGA,EAAItB,KAAKY,SAAUU,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIvB,KAAKY,SAAUW,IACjCvB,KAAKW,KAAKW,GAAGC,GAAK,IAAIlB,EAI1BL,KAAKa,MAAQ,IAAIf,EArBrB,2CAwBE,WACE,OAAOE,KAAKW,OAzBhB,yBA4BE,WACE,OAAOX,KAAKY,WA7BhB,sBAgCE,WACE,OAAOZ,KAAKa,QAjChB,qCAoCE,WACE,IAAQT,EAASJ,KAAKa,MAAMW,eAApBpB,KACR,OAAOJ,KAAKW,KAAKP,EAAKF,KAAKE,EAAKD,KAAKK,YAtCzC,qCAyCE,WACE,IAAQP,EAASD,KAAKa,MAAMW,eAApBvB,KACR,OAAOD,KAAKW,KAAKV,EAAKC,KAAKD,EAAKE,KAAKK,YA3CzC,qCA8CE,SAA+BA,GAC7B,IAAQJ,EAASJ,KAAKa,MAAMW,eAApBpB,KACRJ,KAAKW,KAAKP,EAAKF,KAAKE,EAAKD,KAAKK,UAAYA,IAhD9C,qCAmDE,SAA+BA,GAC7B,IAAQP,EAASD,KAAKa,MAAMW,eAApBvB,KACRD,KAAKW,KAAKV,EAAKC,KAAKD,EAAKE,KAAKK,UAAYA,IArD9C,0BAwDE,WACE,MAAuBR,KAAKa,MAAMW,eAA1BvB,EAAR,EAAQA,KAAMG,EAAd,EAAcA,KAQd,GANAJ,KAAKW,KAAKV,EAAKC,KAAKD,EAAKE,KAAKK,UAAYnB,EAAUoB,KACpDT,KAAKW,KAAKP,EAAKF,KAAKE,EAAKD,KAAKK,UAAYnB,EAAUoB,KAEpDT,KAAKW,KAAKV,EAAKC,KAAKD,EAAKE,KAAKG,KAAOhB,EAAKmC,KAC1CzB,KAAKW,KAAKP,EAAKF,KAAKE,EAAKD,KAAKG,KAAOhB,EAAKoC,KAEtCzB,EAAKC,MAAQE,EAAKF,IAEpB,IAAK,IAAIoB,EAAIrB,EAAKE,IAAM,EAAGmB,EAAIlB,EAAKD,IAAKmB,IACvCtB,KAAKW,KAAKV,EAAKC,KAAKoB,GAAGhB,KAAOhB,EAAKqC,KACnC3B,KAAKW,KAAKP,EAAKF,KAAKoB,GAAGhB,KAAOhB,EAAKqC,SAEhC,IAAI1B,EAAKE,MAAQC,EAAKD,IAO3B,MAAM,IAAIyB,MAAM,sBALhB,IAAK,IAAIN,EAAIrB,EAAKC,IAAM,EAAGoB,EAAIlB,EAAKF,IAAKoB,IACvCtB,KAAKW,KAAKW,GAAGrB,EAAKE,KAAKG,KAAOhB,EAAKqC,KACnC3B,KAAKW,KAAKW,GAAGrB,EAAKE,KAAKG,KAAOhB,EAAKqC,UA3E3C,KGlBaE,G,MAA0CrC,IAAMC,MAAK,SAACC,GACjE,IAAQY,EAA+BZ,EAA/BY,KAAMwB,EAAyBpC,EAAzBoC,qBAERC,EAA4B,SAACC,GACjC,OAAQA,GACN,KAAK3C,EAAU4C,KACb,MAAO,MACT,KAAK5C,EAAU6C,GACb,MAAO,MACT,KAAK7C,EAAU8C,KACb,MAAO,MACT,KAAK9C,EAAU+C,MACb,MAAO,MACT,KAAK/C,EAAUoB,KACb,MAAO,OACT,QACE,MAAM,IAAImB,MAAM,iBAqBlBjC,EAjBiB,WACnB,OAAQW,GACN,KAAKhB,EAAKiB,OACR,MAAO,MACT,KAAKjB,EAAKoC,KACR,MAAM,QAAN,OAAeK,EAA0BD,IAC3C,KAAKxC,EAAKqC,KACR,MAAO,QACT,KAAKrC,EAAKmC,KACR,MAAM,QAAN,OAAeM,EAA0BD,IAC3C,KAAKxC,EAAK+C,KACR,MAAO,OACT,QACE,MAAM,IAAIT,MAAM,iBAINU,GAEhB,OAAO,qBAAK3C,UAAWA,QCvCZ4C,G,MAA4D,SACvE7C,GAEA,IAAQiB,EAA+BjB,EAA/BiB,KAAMmB,EAAyBpC,EAAzBoC,qBAEd,OACE,qBAAKnC,UAAW,OAAhB,SACGgB,EAAK6B,OAAOC,KAAI,SAACC,EAAMC,GAAP,OACf,cAACd,EAAD,CACEvB,KAAMoC,EAAKpC,KACXsC,GAAID,EAEJb,qBAAsBA,GADjBa,U,OClBTE,G,MAAgB,SAACvC,GACrB,OAAQA,GACN,KAAKhB,EAAKqC,KACR,MAAO,IACT,KAAKrC,EAAKoC,KACR,MAAO,IACT,KAAKpC,EAAKmC,KACR,MAAO,IACT,KAAKnC,EAAKiB,OACR,MAAO,IACT,KAAKjB,EAAK+C,KACR,MAAO,IACT,QACE,MAAM,IAAIT,MAAM,mBAIhBkB,EAAqB,SAACtC,GAC1B,OAAQA,GACN,KAAKnB,EAAU4C,KACb,MAAO,IACT,KAAK5C,EAAU6C,GACb,MAAO,IACT,KAAK7C,EAAU8C,KACb,MAAO,IACT,KAAK9C,EAAU+C,MACb,MAAO,IACT,KAAK/C,EAAUoB,KACb,MAAO,IACT,QACE,MAAM,IAAImB,MAAM,uBAITmB,EAA+C,SAACrD,GAC3D,IAAQY,EAAoBZ,EAApBY,KAAME,EAAcd,EAAdc,UACd,OACE,qBAAKb,UAAW,WAAhB,SACE,+BACGW,EAAO,EAAI,6BAAKuC,EAAcvC,KAAc,KAC5CE,EAAY,EAAI,6BAAKsC,EAAmBtC,KAAmB,WCjCvDwC,G,MAAsD,SAACtD,GAClE,IAAQiB,EAASjB,EAATiB,KACR,OACE,qBAAKhB,UAAW,YAAhB,SACGgB,EAAK6B,OAAOC,KAAI,SAACC,EAAMC,GAAP,OACf,cAAC,EAAD,CAAsBrC,KAAMoC,EAAKpC,KAAME,UAAWkC,EAAKlC,WAAxCmC,UCbVM,G,YAAqC,WAChD,OAAO,qBAAKtD,UAAU,qBAAf,qBCQHmB,EAAOC,SAASC,cAAc,SAG9BkC,EAFYhC,iBAAiBJ,GAEPM,iBAAiB,UACvC+B,EACoD,IAAxDC,WAAWF,EAAUG,OAAO,EAAGH,EAAUI,OAAS,IAE9CC,EAAW,IAAIC,IAAIC,OAAOC,SAASC,MACnCC,EAAkB,IAAIC,gBAAgBN,EAAIO,QAE1CC,EAAU,IAAIrD,EACpBqD,EAAQC,eAER,IAAMpD,EAAWmD,EAAQE,cACnBtD,EAAOoD,EAAQG,UAERC,EAAyC,WACpD,MAAkCC,mBAASL,EAAQM,WAAW7C,gBAA9D,mBAAOzB,EAAP,KAAkBuE,EAAlB,KACA,EAA8BF,oBAAS,GAAvC,mBAAOG,EAAP,KAAgBC,EAAhB,KACA,EAA0BJ,oBAAS,GAAnC,mBAAOK,EAAP,KAAcC,EAAd,KAqCMC,EAAWC,uBAAa,CAC5BC,aAnCmB,WACnB,GAAKN,EAAL,CAEA,IAAMO,EAAiBf,EAAQgB,0BAC/BC,QAAQC,IAAIH,GACRA,IAAmBzF,EAAU8C,MAAQ2C,IAAmBzF,EAAU+C,OAEtE2B,EAAQmB,wBAAwB7F,EAAU8C,QA6B1CgD,cA1BoB,WACpB,GAAKZ,EAAL,CACA,IAAMO,EAAiBf,EAAQgB,0BAC3BD,IAAmBzF,EAAU8C,MAAQ2C,IAAmBzF,EAAU+C,OAEtE2B,EAAQmB,wBAAwB7F,EAAU+C,SAsB1CgD,aAXmB,WACnB,GAAKb,EAAL,CACA,IAAMO,EAAiBf,EAAQgB,0BAC3BD,IAAmBzF,EAAU4C,MAAQ6C,IAAmBzF,EAAU6C,IAEtE6B,EAAQmB,wBAAwB7F,EAAU4C,QAO1CoD,WApBiB,WACjB,GAAKd,EAAL,CACA,IAAMO,EAAiBf,EAAQgB,0BAC3BD,IAAmBzF,EAAU4C,MAAQ6C,IAAmBzF,EAAU6C,IAEtE6B,EAAQmB,wBAAwB7F,EAAU6C,MAgB1CoD,8BAA8B,EAC9BC,YAAY,KCvEW,SAACC,EAAsBC,GAC9C,IAAMC,EAAgBC,iBAAOH,GAG7BI,2BAAgB,WACdF,EAAcG,QAAUL,IACvB,CAACA,IAGJM,qBAAU,WAER,GAAKL,EAAL,CAIA,IAAM7C,EAAKmD,aAAY,kBAAML,EAAcG,YAAWJ,GAEtD,OAAO,kBAAMO,cAAcpD,OAC1B,CAAC6C,IDoJNQ,EATe,WACb,IAEMC,EArFW,SAACC,GAClB,IAAIC,EAASrG,EAAUK,KAAKD,IACxBkG,EAAStG,EAAUK,KAAKF,IACtB4E,EAAiBf,EAAQgB,0BAK/B,OAHApE,EAAK0F,GAAQD,GAAQ9F,KAAOhB,EAAKqC,KACjChB,EAAK0F,GAAQD,GAAQ5F,UAAYnB,EAAUoB,KAEnCqE,GACN,KAAKzF,EAAU6C,GACbmE,EACEtG,EAAUK,KAAKF,IAAM,EAAI,EAAIU,EAAW,EAAIb,EAAUK,KAAKF,IAAM,EACnE,MAEF,KAAKb,EAAU4C,KACboE,EACEtG,EAAUK,KAAKF,IAAM,GAAKU,EAAW,EAAIb,EAAUK,KAAKF,IAAM,EAChE,MAEF,KAAKb,EAAU+C,MACbgE,EACErG,EAAUK,KAAKD,IAAM,GAAKS,EAAW,EAAIb,EAAUK,KAAKD,IAAM,EAChE,MAEF,KAAKd,EAAU8C,KACbiE,EACErG,EAAUK,KAAKD,IAAM,EAAI,EAAIS,EAAW,EAAIb,EAAUK,KAAKD,IAAM,EACnE,MAEF,QAEE,MADAqE,GAAW,GACL,IAAI5C,MAAM,2BAGpBuE,EAAK/F,KAAKF,IAAMmG,EAChBF,EAAK/F,KAAKD,IAAMiG,EAEhBzF,EAAK0F,GAAQD,GAAQ9F,KAAOhB,EAAKoC,KACjCf,EAAK0F,GAAQD,GAAQ5F,UAAYsE,EAEjC,IAAMwB,EAAiBvC,EAAQwC,0BAO/B,OANA5F,EAAKZ,EAAUE,KAAKC,KAAKH,EAAUE,KAAKE,KAAKG,KAAOhB,EAAKiB,OACzDI,EAAKZ,EAAUE,KAAKC,KAAKH,EAAUE,KAAKE,KAAKK,UAAYnB,EAAUoB,KAEnE2F,EAASrG,EAAUE,KAAKE,IACxBkG,EAAStG,EAAUE,KAAKC,IAEhBoG,GACN,KAAKjH,EAAU6C,GACbmE,EACEtG,EAAUE,KAAKC,IAAM,EAAI,EAAIU,EAAW,EAAIb,EAAUE,KAAKC,IAAM,EACnE,MAEF,KAAKb,EAAU4C,KACboE,EACEtG,EAAUE,KAAKC,IAAM,GAAKU,EAAW,EAAIb,EAAUE,KAAKC,IAAM,EAChE,MAEF,KAAKb,EAAU+C,MACbgE,EACErG,EAAUE,KAAKE,IAAM,GAAKS,EAAW,EAAIb,EAAUE,KAAKE,IAAM,EAChE,MAEF,KAAKd,EAAU8C,KACbiE,EACErG,EAAUE,KAAKE,IAAM,EAAI,EAAIS,EAAW,EAAIb,EAAUE,KAAKE,IAAM,EACnE,MAEF,QAEE,MADAqE,GAAW,GACL,IAAI5C,MAAM,2BASpB,OALAuE,EAAKlG,KAAKC,IAAMmG,EAChBF,EAAKlG,KAAKE,IAAMiG,EAChBzF,EAAK0F,GAAQD,GAAQ9F,KAAOhB,EAAKmC,KACjCd,EAAK0F,GAAQD,GAAQ5F,UAAY8F,EAE1BH,EAMSK,CAFR,eAAQzG,IAGhBuE,EAAa4B,GAEbnC,EAAQM,WAAWC,aAAa4B,KAMhC3B,EAAUpB,EAAc,MAG1B,IAAMsD,EAAwBC,uBAAY,WACxC,IAAKnC,EAAS,CACZ,IAAM+B,EAAiBvC,EAAQwC,0BACRxC,EAAQgB,4BAGV1F,EAAUoB,MAC7B6F,IAAmBjH,EAAUoB,OAE7BsD,EAAQ4C,wBAAwBtH,EAAU4C,MAC1C8B,EAAQmB,wBAAwB7F,EAAU4C,OAI9CuC,GAAW,SAACD,GAAD,OAAcA,OACxB,CAACA,IAEEqC,EAAgBF,uBAAY,WAChChC,GAAS,SAACD,GAAD,OAAYA,OACpB,IAMH,OACE,gDAASE,GAAT,IAAmBhF,UAAW,gBAA9B,UACG8E,EACC,cAAC,EAAD,CAAW9D,KAAMA,IAEjB,cAAC,EAAD,CACEA,KAAMA,EACNmB,qBAAsBiC,EAAQgB,4BAGlC,sBAAKpF,UAAW,WAAhB,UAEE,cAACJ,EAAD,CACEK,QAAS6G,EACT5G,MAAO0E,EAAU,QAAU,SAjBO,SAAjCX,EAAgBiD,IAAI,SAoBrB,cAACtH,EAAD,CACEK,QAASgH,EACT/G,MAAO4E,EAAQ,YAAc,aAE7B,QAEN,cAAC,EAAD,SE5NOqC,EAAiC,WAC5C,OAAO,8CCCIC,G,MAAkC,WAC7C,OACE,sBAAKpH,UAAW,SAAhB,UACE,sBAAKA,UAAW,WAAhB,UACE,wBAAQA,UAAU,QAAQqH,MAAO,CAAEC,OAAQ,OAA3C,SACG,UAEH,wBAAQtH,UAAU,eAAeqH,MAAO,CAAEC,OAAQ,OAAlD,SACG,mBAGL,cAAC,EAAD,IACA,sBAAKtH,UAAW,YAAhB,UACE,wBAAQA,UAAU,WAAWqH,MAAO,CAAEC,OAAQ,OAA9C,SACG,aAEH,wBAAQtH,UAAU,QAAQqH,MAAO,CAAEC,OAAQ,OAA3C,SACG,kBCfEC,EAA+B,WAC1C,OACE,sBAAKvH,UAAW,eAAhB,UACE,cAAC,EAAD,IACA,cAAC,EAAD,QCLNwH,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFtG,SAASuG,eAAe,W","file":"static/js/main.6d33894b.chunk.js","sourcesContent":["import { Snake } from \"./snake\";\n\nexport enum Direction {\n  None,\n  Up,\n  Down,\n  Right,\n  Left,\n}\n\nexport enum Role {\n  Canvas,\n  Body,\n  Head,\n  Tail,\n  Byte,\n}\n\nexport interface IGridItem {\n  role: Role;\n  direction: Direction;\n}\n\nclass GridItem implements IGridItem {\n  role = Role.Canvas;\n  direction = Direction.None;\n}\n\nexport class Grid {\n  private grid: GridItem[][];\n  private gridSize: number;\n  private snake: Snake; // Grid contains a Snake\n\n  public constructor() {\n    const root = document.querySelector(\":root\")!;\n    const rootStyle = getComputedStyle(root);\n    this.gridSize = parseInt(rootStyle.getPropertyValue(\"--gridSize\"));\n\n    this.grid = new Array(this.gridSize);\n    for (let i = 0; i < this.gridSize; i++) {\n      this.grid[i] = new Array(this.gridSize);\n    }\n\n    for (let i = 0; i < this.gridSize; i++) {\n      for (let j = 0; j < this.gridSize; j++) {\n        this.grid[i][j] = new GridItem();\n      }\n    }\n\n    this.snake = new Snake();\n  }\n\n  public getGrid(): GridItem[][] {\n    return this.grid;\n  }\n\n  public getGridSize(): number {\n    return this.gridSize;\n  }\n\n  public getSnake(): Snake {\n    return this.snake;\n  }\n\n  public getCurrentHeadDirection(): Direction {\n    const { head } = this.snake.getSnakeEnds();\n    return this.grid[head.row][head.col].direction;\n  }\n\n  public getCurrentTailDirection(): Direction {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].direction;\n  }\n\n  public setCurrentHeadDirection(direction: Direction) {\n    const { head } = this.snake.getSnakeEnds();\n    this.grid[head.row][head.col].direction = direction;\n  }\n\n  public setCurrentTailDirection(direction: Direction) {\n    const { tail } = this.snake.getSnakeEnds();\n    this.grid[tail.row][tail.col].direction = direction;\n  }\n\n  public initGridData() {\n    const { tail, head } = this.snake.getSnakeEnds();\n\n    this.grid[tail.row][tail.col].direction = Direction.None;\n    this.grid[head.row][head.col].direction = Direction.None;\n\n    this.grid[tail.row][tail.col].role = Role.Tail;\n    this.grid[head.row][head.col].role = Role.Head;\n\n    if (tail.row === head.row) {\n      // horizontal snake\n      for (let i = tail.col + 1; i < head.col; i++) {\n        this.grid[tail.row][i].role = Role.Body;\n        this.grid[head.row][i].role = Role.Body;\n      }\n    } else if (tail.col === head.col) {\n      // vertical snake\n      for (let i = tail.row + 1; i < head.row; i++) {\n        this.grid[i][tail.col].role = Role.Body;\n        this.grid[i][tail.col].role = Role.Body;\n      }\n    } else {\n      throw new Error(\"Snake init invalid\");\n    }\n  }\n}\n","import React from \"react\";\nimport \"./style/button.css\";\n\ninterface IButtonProps {\n  onClick: () => void;\n  label: string;\n}\n\nexport const Button: React.FunctionComponent<IButtonProps> = React.memo(\n  (props) => {\n    return (\n      <button className={\"newGame\"} onClick={props.onClick}>\n        {props.label}\n      </button>\n    );\n  }\n);\n","// Snake metadata\n\nexport interface ISnakeEnds {\n  tail: { row: number; col: number };\n  head: { row: number; col: number };\n}\n\nexport class Snake {\n  private snakeEnds: ISnakeEnds;\n\n  public constructor(snakeEnds?: ISnakeEnds) {\n    if (snakeEnds) {\n      this.snakeEnds = snakeEnds;\n      return;\n    }\n\n    this.snakeEnds = {\n      tail: { row: 5, col: 5 },\n      head: { row: 8, col: 5 },\n    };\n  }\n\n  public getSnakeEnds(): ISnakeEnds {\n    return this.snakeEnds;\n  }\n\n  public setSnakeEnds(snakeEnds: ISnakeEnds): void {\n    this.snakeEnds = snakeEnds;\n  }\n\n  public snakeAlive(): boolean {\n    // TBD check if the snake head is not collided with a body/tail\n    return true;\n  }\n\n  public snakeLength(): number {\n    // TBD - return the number of grid locations\n    return 4;\n  }\n}\n","import React from \"react\";\nimport { Direction, Role } from \"./grid\";\nimport \"./style/box.css\";\n\ninterface IBoxProps {\n  id: number;\n  role: Role;\n  currentHeadDirection: Direction;\n}\n\nexport const Box: React.FunctionComponent<IBoxProps> = React.memo((props) => {\n  const { role, currentHeadDirection } = props;\n\n  const getClassNameFromDirection = (dir: Direction) => {\n    switch (dir) {\n      case Direction.Down:\n        return \"t2b\";\n      case Direction.Up:\n        return \"b2t\";\n      case Direction.Left:\n        return \"r2l\";\n      case Direction.Right:\n        return \"l2r\";\n      case Direction.None:\n        return \"none\";\n      default:\n        throw new Error(\"invalid dir\");\n    }\n  };\n\n  const getClassName = (): string => {\n    switch (role) {\n      case Role.Canvas:\n        return \"box\";\n      case Role.Head:\n        return `head_${getClassNameFromDirection(currentHeadDirection)}`;\n      case Role.Body:\n        return \"snake\";\n      case Role.Tail:\n        return `tail_${getClassNameFromDirection(currentHeadDirection)}`; // fix this to tail\n      case Role.Byte:\n        return \"food\";\n      default:\n        throw new Error(\"invalid role\");\n    }\n  };\n\n  let className = getClassName();\n\n  return <div className={className}></div>;\n});\n","import React from \"react\";\nimport { Box } from \"./box\";\nimport { Direction, IGridItem } from \"./grid\";\nimport \"./style/grid.css\";\n\ninterface IGridRendererProps {\n  grid: IGridItem[][];\n  currentHeadDirection: Direction;\n}\n\nexport const GridRenderer: React.FunctionComponent<IGridRendererProps> = (\n  props\n) => {\n  const { grid, currentHeadDirection } = props;\n\n  return (\n    <div className={\"grid\"}>\n      {grid.flat().map((item, index) => (\n        <Box\n          role={item.role}\n          id={index}\n          key={index}\n          currentHeadDirection={currentHeadDirection}\n        />\n      ))}\n    </div>\n  );\n};\n","import { IGridItem, Role, Direction } from \"../grid\";\nimport \"../style/debug/debugBox.css\";\n\nconst getStringRole = (role: Role): string => {\n  switch (role) {\n    case Role.Body:\n      return \"b\";\n    case Role.Head:\n      return \"h\";\n    case Role.Tail:\n      return \"t\";\n    case Role.Canvas:\n      return \"c\";\n    case Role.Byte:\n      return \"f\";\n    default:\n      throw new Error(\"invalid role\");\n  }\n};\n\nconst getStringDirection = (direction: Direction): string => {\n  switch (direction) {\n    case Direction.Down:\n      return \"d\";\n    case Direction.Up:\n      return \"u\";\n    case Direction.Left:\n      return \"l\";\n    case Direction.Right:\n      return \"r\";\n    case Direction.None:\n      return \"n\";\n    default:\n      throw new Error(\"invalid direction\");\n  }\n};\n\nexport const DebugBox: React.FunctionComponent<IGridItem> = (props) => {\n  const { role, direction } = props;\n  return (\n    <div className={\"debugBox\"}>\n      <ul>\n        {role > 0 ? <li>{getStringRole(role)}</li> : null}\n        {direction > 0 ? <li>{getStringDirection(direction)}</li> : null}\n      </ul>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { DebugBox } from \"./debugBox\";\nimport { IGridItem } from \"../grid\";\n\nimport \"../style/debug/debugGrid.css\";\n\ninterface IDebugGridProps {\n  grid: IGridItem[][];\n}\n\nexport const DebugGrid: React.FunctionComponent<IDebugGridProps> = (props) => {\n  const { grid } = props;\n  return (\n    <div className={\"debugGrid\"}>\n      {grid.flat().map((item, index) => (\n        <DebugBox key={index} role={item.role} direction={item.direction} />\n      ))}\n    </div>\n  );\n};\n","import \"./style/wordTiles.css\";\n\nexport const WordTiles: React.FunctionComponent = () => {\n  return <div className=\"wordTilesContainer\">SNAKE</div>;\n};\n","import React, { useCallback, useState } from \"react\";\nimport { Score } from \"./score\";\nimport { Button } from \"./button\";\nimport { useInterval } from \"./useInterval\";\nimport { GridRenderer } from \"./gridRenderer\";\nimport { useSwipeable } from \"react-swipeable\";\nimport { Grid, Direction, Role } from \"./grid\";\nimport { DebugGrid } from \"./debug/debugGrid\";\nimport \"./style/gridContainer.css\";\nimport { WordTiles } from \"./wordtiles\";\n\nconst root = document.querySelector(\":root\")!;\nconst rootStyle = getComputedStyle(root);\n\nconst tickCount = rootStyle.getPropertyValue(\"--tick\");\nconst tickCountMs =\n  parseFloat(tickCount.substr(0, tickCount.length - 1)) * 1000;\n\nconst url: URL = new URL(window.location.href);\nconst urlSearchParams = new URLSearchParams(url.search);\n\nconst gridObj = new Grid();\ngridObj.initGridData();\n\nconst gridSize = gridObj.getGridSize();\nconst grid = gridObj.getGrid();\n\nexport const GridContainer: React.FunctionComponent = () => {\n  const [snakeEnds, setSnakeEnds] = useState(gridObj.getSnake().getSnakeEnds());\n  const [playing, setPlaying] = useState(false);\n  const [debug, setDebug] = useState(false);\n\n  // add logic in these to detect game end\n  const onSwipedLeft = () => {\n    if (!playing) return;\n\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    console.log(currentHeadDir);\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Left);\n  };\n\n  const onSwipedRight = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Right);\n  };\n\n  const onSwipedUp = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Up);\n  };\n\n  const onSwipedDown = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Down);\n  };\n\n  const handlers = useSwipeable({\n    onSwipedLeft: onSwipedLeft,\n    onSwipedRight: onSwipedRight,\n    onSwipedDown: onSwipedDown,\n    onSwipedUp: onSwipedUp,\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: true,\n  });\n\n  // calcualte the new snake ends, and assign new roles as necessary\n  const getNewEnds = (ends: typeof snakeEnds) => {\n    let newCol = snakeEnds.head.col;\n    let newRow = snakeEnds.head.row;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n\n    grid[newRow][newCol].role = Role.Body; // make current head -> snake body\n    grid[newRow][newCol].direction = Direction.None; // make current head's dir none\n\n    switch (currentHeadDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.head.row - 1 < 0 ? gridSize - 1 : snakeEnds.head.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.head.row + 1 >= gridSize ? 0 : snakeEnds.head.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.head.col + 1 >= gridSize ? 0 : snakeEnds.head.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.head.col - 1 < 0 ? gridSize - 1 : snakeEnds.head.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid head direction!\");\n      }\n    }\n    ends.head.row = newRow;\n    ends.head.col = newCol;\n\n    grid[newRow][newCol].role = Role.Head; // canvas -> head\n    grid[newRow][newCol].direction = currentHeadDir; // retain previous head's dir in the new head\n\n    const currentTailDir = gridObj.getCurrentTailDirection();\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].role = Role.Canvas; // tail -> canvas\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].direction = Direction.None; // tail -> canvas dir\n\n    newCol = snakeEnds.tail.col;\n    newRow = snakeEnds.tail.row;\n\n    switch (currentTailDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.tail.row - 1 < 0 ? gridSize - 1 : snakeEnds.tail.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.tail.row + 1 >= gridSize ? 0 : snakeEnds.tail.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.tail.col + 1 >= gridSize ? 0 : snakeEnds.tail.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.tail.col - 1 < 0 ? gridSize - 1 : snakeEnds.tail.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid tail direction!\");\n      }\n    }\n\n    ends.tail.row = newRow;\n    ends.tail.col = newCol;\n    grid[newRow][newCol].role = Role.Tail; // body -> tail\n    grid[newRow][newCol].direction = currentTailDir;\n\n    return ends;\n  };\n\n  const onTick = () => {\n    let ends = { ...snakeEnds };\n    // set new roles on the new ends\n    const newEnds = getNewEnds(ends);\n    setSnakeEnds(newEnds);\n    // set new ends\n    gridObj.getSnake().setSnakeEnds(newEnds);\n  };\n\n  useInterval(\n    onTick,\n    // Delay in milliseconds or null to stop it\n    playing ? tickCountMs : null\n  );\n\n  const handleOnPlayPauseGame = useCallback(() => {\n    if (!playing) {\n      const currentTailDir = gridObj.getCurrentTailDirection();\n      const currentHeadDir = gridObj.getCurrentHeadDirection();\n      // on hitting play\n      if (\n        currentHeadDir === Direction.None &&\n        currentTailDir === Direction.None\n      ) {\n        gridObj.setCurrentTailDirection(Direction.Down);\n        gridObj.setCurrentHeadDirection(Direction.Down);\n      }\n    }\n\n    setPlaying((playing) => !playing);\n  }, [playing]);\n\n  const handleOnDebug = useCallback(() => {\n    setDebug((debug) => !debug);\n  }, []);\n\n  const isDebugMode = () => {\n    return urlSearchParams.get(\"debug\") === \"true\";\n  };\n\n  return (\n    <div {...handlers} className={\"gridContainer\"}>\n      {debug ? (\n        <DebugGrid grid={grid} />\n      ) : (\n        <GridRenderer\n          grid={grid}\n          currentHeadDirection={gridObj.getCurrentHeadDirection()}\n        />\n      )}\n      <div className={\"appUtils\"}>\n        {/* <Score currentScore={0}></Score> */}\n        <Button\n          onClick={handleOnPlayPauseGame}\n          label={playing ? \"Pause\" : \"Play\"}\n        />\n        {isDebugMode() ? (\n          <Button\n            onClick={handleOnDebug}\n            label={debug ? \"Debug Off\" : \"Debug On\"}\n          />\n        ) : null}\n      </div>\n      <WordTiles />\n    </div>\n  );\n};\n","import { useEffect, useLayoutEffect, useRef } from \"react\"\n\nexport const useInterval = (callback: () => void, delay: number | null) => {\n    const savedCallback = useRef(callback)\n  \n    // Remember the latest callback if it changes.\n    useLayoutEffect(() => {\n      savedCallback.current = callback\n    }, [callback])\n  \n    // Set up the interval.\n    useEffect(() => {\n      // Don't schedule if no delay is specified.\n      if (!delay) {\n        return\n      }\n  \n      const id = setInterval(() => savedCallback.current(), delay)\n  \n      return () => clearInterval(id)\n    }, [delay])\n  }","import React from \"react\";\n\nexport const Title: React.FunctionComponent = () => {\n  return <h2>Snake Bytes</h2>;\n};\n","import React from \"react\";\nimport { Title } from \"./title\";\nimport \"./style/header.css\";\n\nexport const Header: React.FunctionComponent = () => {\n  return (\n    <div className={\"header\"}>\n      <div className={\"menuleft\"}>\n        <button className=\"About\" style={{ margin: \"2px\" }}>\n          {\"About\"}\n        </button>\n        <button className=\"Instructions\" style={{ margin: \"2px\" }}>\n          {\"How To Play\"}\n        </button>\n      </div>\n      <Title />\n      <div className={\"menuright\"}>\n        <button className=\"Settings\" style={{ margin: \"2px\" }}>\n          {\"Settings\"}\n        </button>\n        <button className=\"Stats\" style={{ margin: \"2px\" }}>\n          {\"Stats\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./style/App.css\";\n\nimport { GridContainer } from \"./gridContainer\";\nimport { Header } from \"./header\";\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <div className={\"appContainer\"}>\n      <Header />\n      <GridContainer />\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/index.css\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}