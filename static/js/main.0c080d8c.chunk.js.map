{"version":3,"sources":["grid.ts","title.tsx","score.tsx","button.tsx","snake.ts","box.tsx","gridRenderer.tsx","debug/debugBox.tsx","debug/debugGrid.tsx","gridContainer.tsx","useInterval.tsx","App.tsx","index.tsx"],"names":["Direction","Role","Title","Score","React","memo","props","currentScore","Button","className","onClick","label","Snake","snakeEnds","this","tail","row","col","head","GridItem","role","Canvas","direction","None","Grid","grid","gridSize","snake","root","document","querySelector","rootStyle","getComputedStyle","parseInt","getPropertyValue","Array","i","j","getSnakeEnds","Tail","Head","Body","Error","Box","currentHeadDirection","getClassNameFromDirection","dir","Down","Up","Left","Right","Byte","getClassName","GridRenderer","flat","map","item","index","id","getStringRole","getStringDirection","DebugBox","DebugGrid","tickCount","tickCountMs","parseFloat","substr","length","url","URL","window","location","href","urlSearchParams","URLSearchParams","search","gridObj","initGridData","getGridSize","getGrid","GridContainer","useState","getSnake","setSnakeEnds","playing","setPlaying","debug","setDebug","handlers","useSwipeable","onSwipedLeft","setCurrentHeadDirection","onSwipedRight","onSwipedDown","onSwipedUp","preventDefaultTouchmoveEvent","trackMouse","callback","delay","savedCallback","useRef","useLayoutEffect","current","useEffect","setInterval","clearInterval","useInterval","newEnds","ends","newCol","newRow","currentHeadDir","getCurrentHeadDirection","currentTailDir","getCurrentTailDirection","getNewEnds","handleOnPlayPauseGame","useCallback","setCurrentTailDirection","handleOnDebug","get","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.0c080d8c.chunk.js","sourcesContent":["import { Snake } from \"./snake\";\n\nexport enum Direction {\n  None,\n  Up,\n  Down,\n  Right,\n  Left,\n}\n\nexport enum Role {\n  Canvas,\n  Body,\n  Head,\n  Tail,\n  Byte,\n}\n\nexport interface IGridItem {\n  role: Role;\n  direction: Direction;\n}\n\nclass GridItem implements IGridItem {\n  role = Role.Canvas;\n  direction = Direction.None;\n}\n\nexport class Grid {\n  private grid: GridItem[][];\n  private gridSize: number;\n  private snake: Snake; // Grid contains a Snake\n\n  public constructor() {\n    const root = document.querySelector(\":root\")!;\n    const rootStyle = getComputedStyle(root);\n    this.gridSize = parseInt(rootStyle.getPropertyValue(\"--gridSize\"));\n\n    this.grid = new Array(this.gridSize);\n    for (let i = 0; i < this.gridSize; i++) {\n      this.grid[i] = new Array(this.gridSize);\n    }\n\n    for (let i = 0; i < this.gridSize; i++) {\n      for (let j = 0; j < this.gridSize; j++) {\n        this.grid[i][j] = new GridItem();\n      }\n    }\n\n    this.snake = new Snake();\n  }\n\n  public getGrid(): GridItem[][] {\n    return this.grid;\n  }\n\n  public getGridSize(): number {\n    return this.gridSize;\n  }\n\n  public getSnake(): Snake {\n    return this.snake;\n  }\n\n  public getCurrentHeadDirection(): Direction {\n    const { head } = this.snake.getSnakeEnds();\n    return this.grid[head.row][head.col].direction;\n  }\n\n  public getCurrentTailDirection(): Direction {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].direction;\n  }\n\n  public setCurrentHeadDirection(direction: Direction) {\n    const { head } = this.snake.getSnakeEnds();\n    this.grid[head.row][head.col].direction = direction;\n  }\n\n  public setCurrentTailDirection(direction: Direction) {\n    const { tail } = this.snake.getSnakeEnds();\n    this.grid[tail.row][tail.col].direction = direction;\n  }\n\n  public initGridData() {\n    const { tail, head } = this.snake.getSnakeEnds();\n\n    this.grid[tail.row][tail.col].direction = Direction.None;\n    this.grid[head.row][head.col].direction = Direction.None;\n\n    this.grid[tail.row][tail.col].role = Role.Tail;\n    this.grid[head.row][head.col].role = Role.Head;\n\n    if (tail.row === head.row) {\n      // horizontal snake\n      for (let i = tail.col + 1; i < head.col; i++) {\n        this.grid[tail.row][i].role = Role.Body;\n        this.grid[head.row][i].role = Role.Body;\n      }\n    } else if (tail.col === head.col) {\n      // vertical snake\n      for (let i = tail.row + 1; i < head.row; i++) {\n        this.grid[i][tail.col].role = Role.Body;\n        this.grid[i][tail.col].role = Role.Body;\n      }\n    } else {\n      throw new Error(\"Snake init invalid\");\n    }\n  }\n}\n","import React from \"react\";\n\nexport const Title: React.FunctionComponent = () => {\n  return <h2>SNAKE</h2>;\n};\n","import React from 'react';\n\ninterface IScoreProps{\n    currentScore:number;\n}\nexport const Score: React.FunctionComponent<IScoreProps> = React.memo((props) => {\n    return <h2>Score: {props.currentScore}</h2>\n});","import React from \"react\";\nimport \"./style/button.css\";\n\ninterface IButtonProps {\n  onClick: () => void;\n  label: string;\n}\n\nexport const Button: React.FunctionComponent<IButtonProps> = React.memo(\n  (props) => {\n    return (\n      <button className={\"newGame\"} onClick={props.onClick}>\n        {props.label}\n      </button>\n    );\n  }\n);\n","// Snake metadata\n\nexport interface ISnakeEnds {\n  tail: { row: number; col: number };\n  head: { row: number; col: number };\n}\n\nexport class Snake {\n  private snakeEnds: ISnakeEnds;\n\n  public constructor(snakeEnds?: ISnakeEnds) {\n    if (snakeEnds) {\n      this.snakeEnds = snakeEnds;\n      return;\n    }\n\n    this.snakeEnds = {\n      tail: { row: 5, col: 5 },\n      head: { row: 8, col: 5 },\n    };\n  }\n\n  public getSnakeEnds(): ISnakeEnds {\n    return this.snakeEnds;\n  }\n\n  public setSnakeEnds(snakeEnds: ISnakeEnds): void {\n    this.snakeEnds = snakeEnds;\n  }\n\n  public snakeAlive(): boolean {\n    // TBD check if the snake head is not collided with a body/tail\n    return true;\n  }\n\n  public snakeLength(): number {\n    // TBD - return the number of grid locations\n    return 4;\n  }\n}\n","import React from \"react\";\nimport { Direction, Role } from \"./grid\";\nimport \"./style/box.css\";\n\ninterface IBoxProps {\n  id: number;\n  role: Role;\n  currentHeadDirection: Direction;\n}\n\nexport const Box: React.FunctionComponent<IBoxProps> = React.memo((props) => {\n  const { role, currentHeadDirection } = props;\n\n  const getClassNameFromDirection = (dir: Direction) => {\n    switch (dir) {\n      case Direction.Down:\n        return \"t2b\";\n      case Direction.Up:\n        return \"b2t\";\n      case Direction.Left:\n        return \"r2l\";\n      case Direction.Right:\n        return \"l2r\";\n      case Direction.None:\n        return \"none\";\n      default:\n        throw new Error(\"invalid dir\");\n    }\n  };\n\n  const getClassName = (): string => {\n    switch (role) {\n      case Role.Canvas:\n        return \"box\";\n      case Role.Head:\n        return `head_${getClassNameFromDirection(currentHeadDirection)}`;\n      case Role.Body:\n        return \"snake\";\n      case Role.Tail:\n        return `tail_${getClassNameFromDirection(currentHeadDirection)}`; // fix this to tail\n      case Role.Byte:\n        return \"food\";\n      default:\n        throw new Error(\"invalid role\");\n    }\n  };\n\n  let className = getClassName();\n\n  return <div className={className}></div>;\n});\n","import React from \"react\";\nimport { Box } from \"./box\";\nimport { Direction, IGridItem } from \"./grid\";\nimport \"./style/grid.css\";\n\ninterface IGridRendererProps {\n  grid: IGridItem[][];\n  currentHeadDirection: Direction;\n}\n\nexport const GridRenderer: React.FunctionComponent<IGridRendererProps> = (\n  props\n) => {\n  const { grid, currentHeadDirection } = props;\n\n  return (\n    <div className={\"grid\"}>\n      {grid.flat().map((item, index) => (\n        <Box\n          role={item.role}\n          id={index}\n          key={index}\n          currentHeadDirection={currentHeadDirection}\n        />\n      ))}\n    </div>\n  );\n};\n","import { IGridItem, Role, Direction } from \"../grid\";\nimport \"../style/debug/debugBox.css\";\n\nconst getStringRole = (role: Role): string => {\n  switch (role) {\n    case Role.Body:\n      return \"b\";\n    case Role.Head:\n      return \"h\";\n    case Role.Tail:\n      return \"t\";\n    case Role.Canvas:\n      return \"c\";\n    case Role.Byte:\n      return \"f\";\n    default:\n      throw new Error(\"invalid role\");\n  }\n};\n\nconst getStringDirection = (direction: Direction): string => {\n  switch (direction) {\n    case Direction.Down:\n      return \"d\";\n    case Direction.Up:\n      return \"u\";\n    case Direction.Left:\n      return \"l\";\n    case Direction.Right:\n      return \"r\";\n    case Direction.None:\n      return \"n\";\n    default:\n      throw new Error(\"invalid direction\");\n  }\n};\n\nexport const DebugBox: React.FunctionComponent<IGridItem> = (props) => {\n  const { role, direction } = props;\n  return (\n    <div className={\"debugBox\"}>\n      <ul>\n        {role > 0 ? <li>{getStringRole(role)}</li> : null}\n        {direction > 0 ? <li>{getStringDirection(direction)}</li> : null}\n      </ul>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { DebugBox } from \"./debugBox\";\nimport { IGridItem } from \"../grid\";\n\nimport \"../style/debug/debugGrid.css\";\n\ninterface IDebugGridProps {\n  grid: IGridItem[][];\n}\n\nexport const DebugGrid: React.FunctionComponent<IDebugGridProps> = (props) => {\n  const { grid } = props;\n  return (\n    <div className={\"debugGrid\"}>\n      {grid.flat().map((item, index) => (\n        <DebugBox key={index} role={item.role} direction={item.direction} />\n      ))}\n    </div>\n  );\n};\n","import React, { useCallback, useState } from \"react\";\nimport { Score } from \"./score\";\nimport { Button } from \"./button\";\nimport { useInterval } from \"./useInterval\";\nimport { GridRenderer } from \"./gridRenderer\";\nimport { useSwipeable } from \"react-swipeable\";\nimport { Grid, Direction, Role } from \"./grid\";\nimport { DebugGrid } from \"./debug/debugGrid\";\n\nconst root = document.querySelector(\":root\")!;\nconst rootStyle = getComputedStyle(root);\n\nconst tickCount = rootStyle.getPropertyValue(\"--tick\");\nconst tickCountMs =\n  parseFloat(tickCount.substr(0, tickCount.length - 1)) * 1000;\n\nconst url: URL = new URL(window.location.href);\nconst urlSearchParams = new URLSearchParams(url.search);\n\nconst gridObj = new Grid();\ngridObj.initGridData();\n\nconst gridSize = gridObj.getGridSize();\nconst grid = gridObj.getGrid();\n\nexport const GridContainer: React.FunctionComponent = () => {\n  const [snakeEnds, setSnakeEnds] = useState(gridObj.getSnake().getSnakeEnds());\n  const [playing, setPlaying] = useState(false);\n  const [debug, setDebug] = useState(false);\n\n  // add logic in these to detect game end\n  const onSwipedLeft = () => {\n    if (!playing) return;\n    gridObj.setCurrentHeadDirection(Direction.Left);\n  };\n  const onSwipedRight = () => {\n    if (!playing) return;\n    gridObj.setCurrentHeadDirection(Direction.Right);\n  };\n  const onSwipedUp = () => {\n    if (!playing) return;\n    gridObj.setCurrentHeadDirection(Direction.Up);\n  };\n  const onSwipedDown = () => {\n    if (!playing) return;\n    gridObj.setCurrentHeadDirection(Direction.Down);\n  };\n\n  const handlers = useSwipeable({\n    onSwipedLeft: onSwipedLeft,\n    onSwipedRight: onSwipedRight,\n    onSwipedDown: onSwipedDown,\n    onSwipedUp: onSwipedUp,\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: true,\n  });\n\n  // calcualte the new snake ends, and assign new roles as necessary\n  const getNewEnds = (ends: typeof snakeEnds) => {\n    let newCol = snakeEnds.head.col;\n    let newRow = snakeEnds.head.row;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n\n    grid[newRow][newCol].role = Role.Body; // make current head -> snake body\n    grid[newRow][newCol].direction = Direction.None; // make current head's dir none\n\n    switch (currentHeadDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.head.row - 1 < 0 ? gridSize - 1 : snakeEnds.head.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.head.row + 1 >= gridSize ? 0 : snakeEnds.head.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.head.col + 1 >= gridSize ? 0 : snakeEnds.head.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.head.col - 1 < 0 ? gridSize - 1 : snakeEnds.head.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid head direction!\");\n      }\n    }\n    ends.head.row = newRow;\n    ends.head.col = newCol;\n\n    grid[newRow][newCol].role = Role.Head; // canvas -> head\n    grid[newRow][newCol].direction = currentHeadDir; // retain previous head's dir in the new head\n\n    const currentTailDir = gridObj.getCurrentTailDirection();\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].role = Role.Canvas; // tail -> canvas\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].direction = Direction.None; // tail -> canvas dir\n\n    newCol = snakeEnds.tail.col;\n    newRow = snakeEnds.tail.row;\n\n    switch (currentTailDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.tail.row - 1 < 0 ? gridSize - 1 : snakeEnds.tail.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.tail.row + 1 >= gridSize ? 0 : snakeEnds.tail.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.tail.col + 1 >= gridSize ? 0 : snakeEnds.tail.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.tail.col - 1 < 0 ? gridSize - 1 : snakeEnds.tail.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid tail direction!\");\n      }\n    }\n\n    ends.tail.row = newRow;\n    ends.tail.col = newCol;\n    grid[newRow][newCol].role = Role.Tail; // body -> tail\n    grid[newRow][newCol].direction = currentTailDir;\n\n    return ends;\n  };\n\n  const onTick = () => {\n    let ends = { ...snakeEnds };\n    // set new roles on the new ends\n    const newEnds = getNewEnds(ends);\n    setSnakeEnds(newEnds);\n    // set new ends\n    gridObj.getSnake().setSnakeEnds(newEnds);\n  };\n\n  useInterval(\n    onTick,\n    // Delay in milliseconds or null to stop it\n    playing ? tickCountMs : null\n  );\n\n  const handleOnPlayPauseGame = useCallback(() => {\n    if (!playing) {\n      const currentTailDir = gridObj.getCurrentTailDirection();\n      const currentHeadDir = gridObj.getCurrentHeadDirection();\n      // on hitting play\n      if (\n        currentHeadDir === Direction.None &&\n        currentTailDir === Direction.None\n      ) {\n        gridObj.setCurrentTailDirection(Direction.Down);\n        gridObj.setCurrentHeadDirection(Direction.Down);\n      }\n    }\n\n    setPlaying((playing) => !playing);\n  }, [playing]);\n\n  const handleOnDebug = useCallback(() => {\n    setDebug((debug) => !debug);\n  }, []);\n\n  const isDebugMode = () => {\n    return urlSearchParams.get(\"debug\") === \"true\";\n  };\n\n  return (\n    <div {...handlers}>\n      {debug ? (\n        <DebugGrid grid={grid} />\n      ) : (\n        <GridRenderer\n          grid={grid}\n          currentHeadDirection={gridObj.getCurrentHeadDirection()}\n        />\n      )}\n      <div className={\"appUtils\"}>\n        <Score currentScore={0}></Score>\n        <Button\n          onClick={handleOnPlayPauseGame}\n          label={playing ? \"Pause\" : \"Play\"}\n        />\n        {isDebugMode() ? (\n          <Button\n            onClick={handleOnDebug}\n            label={debug ? \"Debug Off\" : \"Debug On\"}\n          />\n        ) : null}\n      </div>\n    </div>\n  );\n};\n","import { useEffect, useLayoutEffect, useRef } from \"react\"\n\nexport const useInterval = (callback: () => void, delay: number | null) => {\n    const savedCallback = useRef(callback)\n  \n    // Remember the latest callback if it changes.\n    useLayoutEffect(() => {\n      savedCallback.current = callback\n    }, [callback])\n  \n    // Set up the interval.\n    useEffect(() => {\n      // Don't schedule if no delay is specified.\n      if (!delay) {\n        return\n      }\n  \n      const id = setInterval(() => savedCallback.current(), delay)\n  \n      return () => clearInterval(id)\n    }, [delay])\n  }","import React from \"react\";\nimport \"./style/App.css\";\n\nimport { Title } from \"./title\";\nimport { GridContainer } from \"./gridContainer\";\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <div className={\"appContainer\"}>\n      <Title />\n      <GridContainer />\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/index.css\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}