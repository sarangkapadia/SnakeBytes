{"version":3,"sources":["grid.ts","snake.ts","box.tsx","gridRenderer.tsx","debug/debugBox.tsx","debug/debugGrid.tsx","wordtiles.tsx","gridContainer.tsx","useInterval.tsx","title.tsx","header.tsx","App.tsx","index.tsx"],"names":["Direction","Role","Snake","snakeEnds","this","tail","row","col","head","GridItem","role","Canvas","direction","None","Grid","grid","gridSize","snake","root","document","querySelector","rootStyle","getComputedStyle","parseInt","getPropertyValue","Array","i","j","getSnakeEnds","Tail","Head","Body","Error","Box","React","memo","props","currentHeadDirection","getClassNameFromDirection","dir","Down","Up","Left","Right","className","Byte","getClassName","GridRenderer","flat","map","item","index","id","getStringRole","getStringDirection","DebugBox","DebugGrid","WordTiles","tickCount","tickCountMs","parseFloat","substr","length","url","URL","window","location","href","gridObj","URLSearchParams","search","initGridData","getGridSize","getGrid","GridContainer","useState","getSnake","setSnakeEnds","playing","setPlaying","debug","setDebug","handlers","useSwipeable","onSwipedLeft","currentHeadDir","getCurrentHeadDirection","console","log","setCurrentHeadDirection","onSwipedRight","onSwipedDown","onSwipedUp","preventDefaultTouchmoveEvent","trackMouse","callback","delay","savedCallback","useRef","useLayoutEffect","current","useEffect","setInterval","clearInterval","useInterval","newEnds","ends","newCol","newRow","currentTailDir","getCurrentTailDirection","getNewEnds","useCallback","setCurrentTailDirection","Title","Header","style","margin","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.8ecdb20d.chunk.js","sourcesContent":["import { Snake } from \"./snake\";\n\nexport enum Direction {\n  None,\n  Up,\n  Down,\n  Right,\n  Left,\n}\n\nexport enum Role {\n  Canvas,\n  Body,\n  Head,\n  Tail,\n  Byte,\n}\n\nexport interface IGridItem {\n  role: Role;\n  direction: Direction;\n}\n\nclass GridItem implements IGridItem {\n  role = Role.Canvas;\n  direction = Direction.None;\n}\n\nexport class Grid {\n  private grid: GridItem[][];\n  private gridSize: number;\n  private snake: Snake; // Grid contains a Snake\n\n  public constructor() {\n    const root = document.querySelector(\":root\")!;\n    const rootStyle = getComputedStyle(root);\n    this.gridSize = parseInt(rootStyle.getPropertyValue(\"--gridSize\"));\n\n    this.grid = new Array(this.gridSize);\n    for (let i = 0; i < this.gridSize; i++) {\n      this.grid[i] = new Array(this.gridSize);\n    }\n\n    for (let i = 0; i < this.gridSize; i++) {\n      for (let j = 0; j < this.gridSize; j++) {\n        this.grid[i][j] = new GridItem();\n      }\n    }\n\n    this.snake = new Snake();\n  }\n\n  public getGrid(): GridItem[][] {\n    return this.grid;\n  }\n\n  public getGridSize(): number {\n    return this.gridSize;\n  }\n\n  public getSnake(): Snake {\n    return this.snake;\n  }\n\n  public getCurrentHeadDirection(): Direction {\n    const { head } = this.snake.getSnakeEnds();\n    return this.grid[head.row][head.col].direction;\n  }\n\n  public getCurrentTailDirection(): Direction {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].direction;\n  }\n\n  public setCurrentHeadDirection(direction: Direction) {\n    const { head } = this.snake.getSnakeEnds();\n    this.grid[head.row][head.col].direction = direction;\n  }\n\n  public setCurrentTailDirection(direction: Direction) {\n    const { tail } = this.snake.getSnakeEnds();\n    this.grid[tail.row][tail.col].direction = direction;\n  }\n\n  public initGridData() {\n    const { tail, head } = this.snake.getSnakeEnds();\n\n    this.grid[tail.row][tail.col].direction = Direction.None;\n    this.grid[head.row][head.col].direction = Direction.None;\n\n    this.grid[tail.row][tail.col].role = Role.Tail;\n    this.grid[head.row][head.col].role = Role.Head;\n\n    if (tail.row === head.row) {\n      // horizontal snake\n      for (let i = tail.col + 1; i < head.col; i++) {\n        this.grid[tail.row][i].role = Role.Body;\n        this.grid[head.row][i].role = Role.Body;\n      }\n    } else if (tail.col === head.col) {\n      // vertical snake\n      for (let i = tail.row + 1; i < head.row; i++) {\n        this.grid[i][tail.col].role = Role.Body;\n        this.grid[i][tail.col].role = Role.Body;\n      }\n    } else {\n      throw new Error(\"Snake init invalid\");\n    }\n  }\n}\n","// Snake metadata\n\nexport interface ISnakeEnds {\n  tail: { row: number; col: number };\n  head: { row: number; col: number };\n}\n\nexport class Snake {\n  private snakeEnds: ISnakeEnds;\n\n  public constructor(snakeEnds?: ISnakeEnds) {\n    if (snakeEnds) {\n      this.snakeEnds = snakeEnds;\n      return;\n    }\n\n    this.snakeEnds = {\n      tail: { row: 5, col: 5 },\n      head: { row: 8, col: 5 },\n    };\n  }\n\n  public getSnakeEnds(): ISnakeEnds {\n    return this.snakeEnds;\n  }\n\n  public setSnakeEnds(snakeEnds: ISnakeEnds): void {\n    this.snakeEnds = snakeEnds;\n  }\n\n  public snakeAlive(): boolean {\n    // TBD check if the snake head is not collided with a body/tail\n    return true;\n  }\n\n  public snakeLength(): number {\n    // TBD - return the number of grid locations\n    return 4;\n  }\n}\n","import React from \"react\";\nimport { Direction, Role } from \"./grid\";\nimport \"./style/box.css\";\n\ninterface IBoxProps {\n  id: number;\n  role: Role;\n  currentHeadDirection: Direction;\n}\n\nexport const Box: React.FunctionComponent<IBoxProps> = React.memo((props) => {\n  const { role, currentHeadDirection } = props;\n\n  const getClassNameFromDirection = (dir: Direction) => {\n    switch (dir) {\n      case Direction.Down:\n        return \"t2b\";\n      case Direction.Up:\n        return \"b2t\";\n      case Direction.Left:\n        return \"r2l\";\n      case Direction.Right:\n        return \"l2r\";\n      case Direction.None:\n        return \"none\";\n      default:\n        throw new Error(\"invalid dir\");\n    }\n  };\n\n  const getClassName = (): string => {\n    switch (role) {\n      case Role.Canvas:\n        return \"box\";\n      case Role.Head:\n        return `head_${getClassNameFromDirection(currentHeadDirection)}`;\n      case Role.Body:\n        return \"snake\";\n      case Role.Tail:\n        return `tail_${getClassNameFromDirection(currentHeadDirection)}`; // fix this to tail\n      case Role.Byte:\n        return \"food\";\n      default:\n        throw new Error(\"invalid role\");\n    }\n  };\n\n  let className = getClassName();\n\n  return <div className={className}></div>;\n});\n","import React from \"react\";\nimport { Box } from \"./box\";\nimport { Direction, IGridItem } from \"./grid\";\nimport \"./style/grid.css\";\n\ninterface IGridRendererProps {\n  grid: IGridItem[][];\n  currentHeadDirection: Direction;\n}\n\nexport const GridRenderer: React.FunctionComponent<IGridRendererProps> = (\n  props\n) => {\n  const { grid, currentHeadDirection } = props;\n\n  return (\n    <div className={\"grid\"}>\n      {grid.flat().map((item, index) => (\n        <Box\n          role={item.role}\n          id={index}\n          key={index}\n          currentHeadDirection={currentHeadDirection}\n        />\n      ))}\n    </div>\n  );\n};\n","import { IGridItem, Role, Direction } from \"../grid\";\nimport \"../style/debug/debugBox.css\";\n\nconst getStringRole = (role: Role): string => {\n  switch (role) {\n    case Role.Body:\n      return \"b\";\n    case Role.Head:\n      return \"h\";\n    case Role.Tail:\n      return \"t\";\n    case Role.Canvas:\n      return \"c\";\n    case Role.Byte:\n      return \"f\";\n    default:\n      throw new Error(\"invalid role\");\n  }\n};\n\nconst getStringDirection = (direction: Direction): string => {\n  switch (direction) {\n    case Direction.Down:\n      return \"d\";\n    case Direction.Up:\n      return \"u\";\n    case Direction.Left:\n      return \"l\";\n    case Direction.Right:\n      return \"r\";\n    case Direction.None:\n      return \"n\";\n    default:\n      throw new Error(\"invalid direction\");\n  }\n};\n\nexport const DebugBox: React.FunctionComponent<IGridItem> = (props) => {\n  const { role, direction } = props;\n  return (\n    <div className={\"debugBox\"}>\n      <ul>\n        {role > 0 ? <li>{getStringRole(role)}</li> : null}\n        {direction > 0 ? <li>{getStringDirection(direction)}</li> : null}\n      </ul>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { DebugBox } from \"./debugBox\";\nimport { IGridItem } from \"../grid\";\n\nimport \"../style/debug/debugGrid.css\";\n\ninterface IDebugGridProps {\n  grid: IGridItem[][];\n}\n\nexport const DebugGrid: React.FunctionComponent<IDebugGridProps> = (props) => {\n  const { grid } = props;\n  return (\n    <div className={\"debugGrid\"}>\n      {grid.flat().map((item, index) => (\n        <DebugBox key={index} role={item.role} direction={item.direction} />\n      ))}\n    </div>\n  );\n};\n","import \"./style/wordTiles.css\";\n\nexport const WordTiles: React.FunctionComponent = () => {\n  return <div className=\"wordTilesContainer\">SNAKE</div>;\n};\n","import React, { useCallback, useState } from \"react\";\nimport { Button } from \"./button\";\nimport { useInterval } from \"./useInterval\";\nimport { GridRenderer } from \"./gridRenderer\";\nimport { useSwipeable } from \"react-swipeable\";\nimport { Grid, Direction, Role } from \"./grid\";\nimport { DebugGrid } from \"./debug/debugGrid\";\nimport \"./style/gridContainer.css\";\nimport { WordTiles } from \"./wordtiles\";\n\nconst root = document.querySelector(\":root\")!;\nconst rootStyle = getComputedStyle(root);\n\nconst tickCount = rootStyle.getPropertyValue(\"--tick\");\nconst tickCountMs =\n  parseFloat(tickCount.substr(0, tickCount.length - 1)) * 1000;\n\nconst url: URL = new URL(window.location.href);\nconst urlSearchParams = new URLSearchParams(url.search);\n\nconst gridObj = new Grid();\ngridObj.initGridData();\n\nconst gridSize = gridObj.getGridSize();\nconst grid = gridObj.getGrid();\n\nexport const GridContainer: React.FunctionComponent = () => {\n  const [snakeEnds, setSnakeEnds] = useState(gridObj.getSnake().getSnakeEnds());\n  const [playing, setPlaying] = useState(false);\n  const [debug, setDebug] = useState(false);\n\n  // add logic in these to detect game end\n  const onSwipedLeft = () => {\n    if (!playing) return;\n\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    console.log(currentHeadDir);\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Left);\n  };\n\n  const onSwipedRight = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Right);\n  };\n\n  const onSwipedUp = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Up);\n  };\n\n  const onSwipedDown = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Down);\n  };\n\n  const handlers = useSwipeable({\n    onSwipedLeft: onSwipedLeft,\n    onSwipedRight: onSwipedRight,\n    onSwipedDown: onSwipedDown,\n    onSwipedUp: onSwipedUp,\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: true,\n  });\n\n  // calcualte the new snake ends, and assign new roles as necessary\n  const getNewEnds = (ends: typeof snakeEnds) => {\n    let newCol = snakeEnds.head.col;\n    let newRow = snakeEnds.head.row;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n\n    grid[newRow][newCol].role = Role.Body; // make current head -> snake body\n    grid[newRow][newCol].direction = Direction.None; // make current head's dir none\n\n    switch (currentHeadDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.head.row - 1 < 0 ? gridSize - 1 : snakeEnds.head.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.head.row + 1 >= gridSize ? 0 : snakeEnds.head.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.head.col + 1 >= gridSize ? 0 : snakeEnds.head.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.head.col - 1 < 0 ? gridSize - 1 : snakeEnds.head.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid head direction!\");\n      }\n    }\n    ends.head.row = newRow;\n    ends.head.col = newCol;\n\n    grid[newRow][newCol].role = Role.Head; // canvas -> head\n    grid[newRow][newCol].direction = currentHeadDir; // retain previous head's dir in the new head\n\n    const currentTailDir = gridObj.getCurrentTailDirection();\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].role = Role.Canvas; // tail -> canvas\n    grid[snakeEnds.tail.row][snakeEnds.tail.col].direction = Direction.None; // tail -> canvas dir\n\n    newCol = snakeEnds.tail.col;\n    newRow = snakeEnds.tail.row;\n\n    switch (currentTailDir) {\n      case Direction.Up: {\n        newRow =\n          snakeEnds.tail.row - 1 < 0 ? gridSize - 1 : snakeEnds.tail.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newRow =\n          snakeEnds.tail.row + 1 >= gridSize ? 0 : snakeEnds.tail.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newCol =\n          snakeEnds.tail.col + 1 >= gridSize ? 0 : snakeEnds.tail.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newCol =\n          snakeEnds.tail.col - 1 < 0 ? gridSize - 1 : snakeEnds.tail.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid tail direction!\");\n      }\n    }\n\n    ends.tail.row = newRow;\n    ends.tail.col = newCol;\n    grid[newRow][newCol].role = Role.Tail; // body -> tail\n    grid[newRow][newCol].direction = currentTailDir;\n\n    return ends;\n  };\n\n  const onTick = () => {\n    let ends = { ...snakeEnds };\n    // set new roles on the new ends\n    const newEnds = getNewEnds(ends);\n    setSnakeEnds(newEnds);\n    // set new ends\n    gridObj.getSnake().setSnakeEnds(newEnds);\n  };\n\n  useInterval(\n    onTick,\n    // Delay in milliseconds or null to stop it\n    playing ? tickCountMs : null\n  );\n\n  const handleOnPlayPauseGame = useCallback(() => {\n    if (!playing) {\n      const currentTailDir = gridObj.getCurrentTailDirection();\n      const currentHeadDir = gridObj.getCurrentHeadDirection();\n      // on hitting play\n      if (\n        currentHeadDir === Direction.None &&\n        currentTailDir === Direction.None\n      ) {\n        gridObj.setCurrentTailDirection(Direction.Down);\n        gridObj.setCurrentHeadDirection(Direction.Down);\n      }\n    }\n\n    setPlaying((playing) => !playing);\n  }, [playing]);\n\n  const handleOnDebug = useCallback(() => {\n    setDebug((debug) => !debug);\n  }, []);\n\n  const isDebugMode = () => {\n    return urlSearchParams.get(\"debug\") === \"true\";\n  };\n\n  return (\n    <div {...handlers} className={\"game\"}>\n      <div className={\"gridContainer\"}>\n        {debug ? (\n          <DebugGrid grid={grid} />\n        ) : (\n          <GridRenderer\n            grid={grid}\n            currentHeadDirection={gridObj.getCurrentHeadDirection()}\n          />\n        )}\n      </div>\n      {/* <div className={\"appUtils\"}>\n        { <Button\n          onClick={handleOnPlayPauseGame}\n          label={playing ? \"Pause\" : \"Play\"}\n        /> }\n        {isDebugMode() ? (\n          <Button\n            onClick={handleOnDebug}\n            label={debug ? \"Debug Off\" : \"Debug On\"}\n          />\n        ) : null}\n      </div> */}\n      <WordTiles />\n    </div>\n  );\n};\n","import { useEffect, useLayoutEffect, useRef } from \"react\"\n\nexport const useInterval = (callback: () => void, delay: number | null) => {\n    const savedCallback = useRef(callback)\n  \n    // Remember the latest callback if it changes.\n    useLayoutEffect(() => {\n      savedCallback.current = callback\n    }, [callback])\n  \n    // Set up the interval.\n    useEffect(() => {\n      // Don't schedule if no delay is specified.\n      if (!delay) {\n        return\n      }\n  \n      const id = setInterval(() => savedCallback.current(), delay)\n  \n      return () => clearInterval(id)\n    }, [delay])\n  }","import React from \"react\";\nimport \"./style/title.css\";\n\nexport const Title: React.FunctionComponent = () => {\n  return <div className=\"title\">Snake Bytes</div>;\n};\n","import React from \"react\";\nimport { Title } from \"./title\";\nimport \"./style/header.css\";\n\nexport const Header: React.FunctionComponent = () => {\n  return (\n    <div className={\"header\"}>\n      <div className={\"menuleft\"}>\n        <button className=\"About\" style={{ margin: \"2px\" }}>\n          {\"About\"}\n        </button>\n        <button className=\"Instructions\" style={{ margin: \"2px\" }}>\n          {\"How\"}\n        </button>\n      </div>\n      <Title />\n      <div className={\"menuright\"}>\n        <button className=\"Sett\" style={{ margin: \"2px\" }}>\n          {\"Settings\"}\n        </button>\n        <button className=\"Stat\" style={{ margin: \"2px\" }}>\n          {\"Stats\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./style/App.css\";\n\nimport { GridContainer } from \"./gridContainer\";\nimport { Header } from \"./header\";\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <div className={\"appContainer\"}>\n      <Header />\n      <GridContainer />\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/index.css\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}