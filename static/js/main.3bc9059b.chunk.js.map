{"version":3,"sources":["grid.ts","button.tsx","snake.ts","box.tsx","gridRenderer.tsx","debug/debugBox.tsx","debug/debugGrid.tsx","wordtiles.tsx","gridContainer.tsx","useInterval.tsx","title.tsx","header.tsx","App.tsx","index.tsx"],"names":["Direction","Role","Button","React","memo","props","className","onClick","label","Snake","snakeEnds","this","tail","row","col","head","GridItem","role","Canvas","direction","None","pivot","Grid","grid","gridSize","snake","root","document","querySelector","rootStyle","getComputedStyle","parseInt","getPropertyValue","Array","i","j","getSnakeEnds","Tail","Head","Body","Error","Box","currentHeadDirection","currentTailDirection","currentTailPivot","getClassNameFromDirection","dir","Down","Up","Left","Right","Byte","getClassName","GridRenderer","flat","map","item","index","id","getStringRole","getStringDirection","DebugBox","toUpperCase","DebugGrid","WordTiles","tickCount","tickCountMs","parseFloat","substr","length","url","URL","window","location","href","urlSearchParams","URLSearchParams","search","gridObj","initGridData","getGridSize","getGrid","GridContainer","useState","getSnake","setSnakeEnds","playing","setPlaying","debug","setDebug","getNewEnds","ends","currentTailRow","currentTailCol","pivotDir","currentTailDir","getCurrentTailDirection","newTailRow","newTailCol","calculateNewTail","currentHeadRow","currentHeadCol","currentHeadDir","getCurrentHeadDirection","newHeadRow","newHeadCol","console","log","calculateNewHead","callback","delay","savedCallback","useRef","useLayoutEffect","current","useEffect","setInterval","clearInterval","useInterval","newEnds","handleOnPlayPauseGame","useCallback","setCurrentTailDirection","setCurrentHeadDirection","handleOnDebug","handlers","useSwipeable","onSwipedLeft","setPivotOnCurrentHeadDirection","onSwipedRight","onSwipedDown","onSwipedUp","preventDefaultTouchmoveEvent","trackMouse","getPivotDirectionOnCurrentTail","get","Title","Header","style","margin","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3bc9059b.chunk.js","sourcesContent":["import { Snake } from \"./snake\";\n\nexport enum Direction {\n  None,\n  Up,\n  Down,\n  Right,\n  Left,\n}\n\nexport enum Role {\n  Canvas,\n  Body,\n  Head,\n  Tail,\n  Byte,\n}\n\nexport interface IGridItem {\n  role: Role;\n  direction: Direction;\n  pivot: Direction;\n}\n\nclass GridItem implements IGridItem {\n  role = Role.Canvas;\n  direction = Direction.None;\n  pivot = Direction.None;\n}\n\nexport class Grid {\n  private grid: GridItem[][];\n  private gridSize: number;\n  private snake: Snake; // Grid contains a Snake\n\n  public constructor() {\n    const root = document.querySelector(\":root\")!;\n    const rootStyle = getComputedStyle(root);\n    this.gridSize = parseInt(rootStyle.getPropertyValue(\"--gridSize\"));\n\n    this.grid = new Array(this.gridSize);\n    for (let i = 0; i < this.gridSize; i++) {\n      this.grid[i] = new Array(this.gridSize);\n    }\n\n    for (let i = 0; i < this.gridSize; i++) {\n      for (let j = 0; j < this.gridSize; j++) {\n        this.grid[i][j] = new GridItem();\n      }\n    }\n\n    this.snake = new Snake();\n  }\n\n  public getGrid(): GridItem[][] {\n    return this.grid;\n  }\n\n  public getGridSize(): number {\n    return this.gridSize;\n  }\n\n  public getSnake(): Snake {\n    return this.snake;\n  }\n\n  public getCurrentHeadDirection(): Direction {\n    const { head } = this.snake.getSnakeEnds();\n    return this.grid[head.row][head.col].direction;\n  }\n\n  public getCurrentTailDirection(): Direction {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].direction;\n  }\n\n  public setCurrentHeadDirection(direction: Direction) {\n    const { head } = this.snake.getSnakeEnds();\n    this.grid[head.row][head.col].direction = direction;\n  }\n\n  public getPivotDirectionOnCurrentTail() {\n    const { tail } = this.snake.getSnakeEnds();\n    return this.grid[tail.row][tail.col].pivot;\n  }\n\n  public setCurrentTailDirection(direction: Direction) {\n    const { tail } = this.snake.getSnakeEnds();\n    this.grid[tail.row][tail.col].direction = direction;\n  }\n\n  setPivotOnCurrentHeadDirection(pivot: Direction) {\n    const { head } = this.snake.getSnakeEnds();\n    this.grid[head.row][head.col].pivot = pivot;\n  }\n\n  public initGridData() {\n    const { tail, head } = this.snake.getSnakeEnds();\n\n    this.grid[tail.row][tail.col].direction = Direction.None;\n    this.grid[head.row][head.col].direction = Direction.None;\n\n    this.grid[tail.row][tail.col].role = Role.Tail;\n    this.grid[head.row][head.col].role = Role.Head;\n\n    if (tail.row === head.row) {\n      // horizontal snake\n      for (let i = tail.col + 1; i < head.col; i++) {\n        this.grid[tail.row][i].role = Role.Body;\n        this.grid[head.row][i].role = Role.Body;\n      }\n    } else if (tail.col === head.col) {\n      // vertical snake\n      for (let i = tail.row + 1; i < head.row; i++) {\n        this.grid[i][tail.col].role = Role.Body;\n        this.grid[i][tail.col].role = Role.Body;\n      }\n    } else {\n      throw new Error(\"Snake init invalid\");\n    }\n  }\n}\n","import React from \"react\";\nimport \"./style/button.css\";\n\ninterface IButtonProps {\n  onClick: () => void;\n  label: string;\n}\n\nexport const Button: React.FunctionComponent<IButtonProps> = React.memo(\n  (props) => {\n    return (\n      <button className={\"newGame\"} onClick={props.onClick}>\n        {props.label}\n      </button>\n    );\n  }\n);\n","// Snake metadata\n\nexport interface ISnakeEnds {\n  tail: { row: number; col: number };\n  head: { row: number; col: number };\n}\n\nexport class Snake {\n  private snakeEnds: ISnakeEnds;\n\n  public constructor(snakeEnds?: ISnakeEnds) {\n    if (snakeEnds) {\n      this.snakeEnds = snakeEnds;\n      return;\n    }\n\n    this.snakeEnds = {\n      tail: { row: 5, col: 5 },\n      head: { row: 12, col: 5 },\n    };\n  }\n\n  public getSnakeEnds(): ISnakeEnds {\n    return this.snakeEnds;\n  }\n\n  public setSnakeEnds(snakeEnds: ISnakeEnds): void {\n    this.snakeEnds = snakeEnds;\n  }\n\n  public snakeAlive(): boolean {\n    // TBD check if the snake head is not collided with a body/tail\n    return true;\n  }\n\n  public snakeLength(): number {\n    // TBD - return the number of grid locations\n    return 4;\n  }\n}\n","import React from \"react\";\nimport { Direction, Role } from \"./grid\";\nimport \"./style/box.css\";\n\ninterface IBoxProps {\n  id: number;\n  role: Role;\n  currentHeadDirection: Direction;\n  currentTailDirection: Direction;\n  currentTailPivot: Direction;\n}\n\nexport const Box: React.FunctionComponent<IBoxProps> = React.memo((props) => {\n  const { role, currentHeadDirection, currentTailDirection, currentTailPivot } =\n    props;\n\n  const getClassNameFromDirection = (dir: Direction) => {\n    switch (dir) {\n      case Direction.Down:\n        return \"t2b\";\n      case Direction.Up:\n        return \"b2t\";\n      case Direction.Left:\n        return \"r2l\";\n      case Direction.Right:\n        return \"l2r\";\n      case Direction.None:\n        return \"none\";\n      default:\n        throw new Error(\"invalid dir\");\n    }\n  };\n\n  const getClassName = (): string => {\n    switch (role) {\n      case Role.Canvas:\n        return \"box\";\n      case Role.Head:\n        return `head_${getClassNameFromDirection(currentHeadDirection)}`;\n      case Role.Body:\n        return \"snake\";\n      case Role.Tail:\n        return `tail_${getClassNameFromDirection(\n          currentTailPivot !== Direction.None\n            ? currentTailPivot\n            : currentTailDirection\n        )}`;\n      case Role.Byte:\n        return \"food\";\n      default:\n        throw new Error(\"invalid role\");\n    }\n  };\n\n  let className = getClassName();\n\n  return <div className={className}></div>;\n});\n","import React from \"react\";\nimport { Box } from \"./box\";\nimport { Direction, IGridItem } from \"./grid\";\nimport \"./style/grid.css\";\n\ninterface IGridRendererProps {\n  grid: IGridItem[][];\n  currentHeadDirection: Direction;\n  currentTailDirection: Direction;\n  currentTailPivot: Direction;\n}\n\nexport const GridRenderer: React.FunctionComponent<IGridRendererProps> = (\n  props\n) => {\n  const { grid, currentHeadDirection, currentTailDirection, currentTailPivot } =\n    props;\n\n  return (\n    <div className={\"grid\"}>\n      {grid.flat().map((item, index) => (\n        <Box\n          role={item.role}\n          id={index}\n          key={index}\n          currentHeadDirection={currentHeadDirection}\n          currentTailDirection={currentTailDirection}\n          currentTailPivot={currentTailPivot}\n        />\n      ))}\n    </div>\n  );\n};\n","import { IGridItem, Role, Direction } from \"../grid\";\nimport \"../style/debug/debugBox.css\";\n\nconst getStringRole = (role: Role): string => {\n  switch (role) {\n    case Role.Body:\n      return \"b \";\n    case Role.Head:\n      return \"h \";\n    case Role.Tail:\n      return \"t \";\n    case Role.Canvas:\n      return \"c \";\n    case Role.Byte:\n      return \"f \";\n    default:\n      throw new Error(\"invalid role\");\n  }\n};\n\nconst getStringDirection = (direction: Direction): string => {\n  switch (direction) {\n    case Direction.Down:\n      return \"d \";\n    case Direction.Up:\n      return \"u \";\n    case Direction.Left:\n      return \"l \";\n    case Direction.Right:\n      return \"r \";\n    case Direction.None:\n      return \"n \";\n    default:\n      throw new Error(\"invalid direction\");\n  }\n};\n\nexport const DebugBox: React.FunctionComponent<IGridItem> = (props) => {\n  const { role, direction, pivot } = props;\n  return (\n    <div className={\"debugBox\"}>\n      {role > 0 ? getStringRole(role) : null}\n      {direction > 0 ? getStringDirection(direction) : null}\n      {role > 0 ? getStringDirection(pivot).toUpperCase() : null}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { DebugBox } from \"./debugBox\";\nimport { IGridItem } from \"../grid\";\n\nimport \"../style/debug/debugGrid.css\";\n\ninterface IDebugGridProps {\n  grid: IGridItem[][];\n}\n\nexport const DebugGrid: React.FunctionComponent<IDebugGridProps> = (props) => {\n  const { grid } = props;\n  return (\n    <div className={\"debugGrid\"}>\n      {grid.flat().map((item, index) => (\n        <DebugBox\n          key={index}\n          role={item.role}\n          direction={item.direction}\n          pivot={item.pivot}\n        />\n      ))}\n    </div>\n  );\n};\n","import \"./style/wordTiles.css\";\n\nexport const WordTiles: React.FunctionComponent = () => {\n  return <div className=\"wordTilesContainer\">SNAKE</div>;\n};\n","import React, { useCallback, useState } from \"react\";\nimport { Button } from \"./button\";\nimport { useInterval } from \"./useInterval\";\nimport { GridRenderer } from \"./gridRenderer\";\nimport { useSwipeable } from \"react-swipeable\";\nimport { Grid, Direction, Role } from \"./grid\";\nimport { DebugGrid } from \"./debug/debugGrid\";\nimport \"./style/gridContainer.css\";\nimport { WordTiles } from \"./wordtiles\";\n\nconst root = document.querySelector(\":root\")!;\nconst rootStyle = getComputedStyle(root);\n\nconst tickCount = rootStyle.getPropertyValue(\"--tick\");\nconst tickCountMs =\n  parseFloat(tickCount.substr(0, tickCount.length - 1)) * 1000;\n\nconst url: URL = new URL(window.location.href);\nconst urlSearchParams = new URLSearchParams(url.search);\n\nconst gridObj = new Grid();\ngridObj.initGridData();\n\nconst gridSize = gridObj.getGridSize();\nconst grid = gridObj.getGrid();\n\nexport const GridContainer: React.FunctionComponent = () => {\n  const [snakeEnds, setSnakeEnds] = useState(gridObj.getSnake().getSnakeEnds());\n  const [playing, setPlaying] = useState(false);\n  const [debug, setDebug] = useState(false);\n\n  // add logic in these to detect game end\n  const onSwipedLeft = () => {\n    if (!playing) return;\n\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Left);\n    gridObj.setPivotOnCurrentHeadDirection(Direction.Left);\n  };\n\n  const onSwipedRight = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Left || currentHeadDir === Direction.Right)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Right);\n    gridObj.setPivotOnCurrentHeadDirection(Direction.Right);\n  };\n\n  const onSwipedUp = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Up);\n    gridObj.setPivotOnCurrentHeadDirection(Direction.Up);\n  };\n\n  const onSwipedDown = () => {\n    if (!playing) return;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n    if (currentHeadDir === Direction.Down || currentHeadDir === Direction.Up)\n      return;\n    gridObj.setCurrentHeadDirection(Direction.Down);\n    gridObj.setPivotOnCurrentHeadDirection(Direction.Down);\n  };\n\n  const calculateNewHead = (ends: typeof snakeEnds) => {\n    /* ========================= HEAD ==============================*/\n    const currentHeadRow = snakeEnds.head.row;\n    const currentHeadCol = snakeEnds.head.col;\n    const currentHeadDir = gridObj.getCurrentHeadDirection();\n\n    grid[currentHeadRow][currentHeadCol].role = Role.Body; // make current head -> snake body\n    grid[currentHeadRow][currentHeadCol].direction = Direction.None; // make current head's dir none\n\n    // now calculate the new position (row, col) for head based on the current head direction.\n    let newHeadRow = currentHeadRow;\n    let newHeadCol = currentHeadCol;\n\n    switch (currentHeadDir) {\n      case Direction.Up: {\n        newHeadRow =\n          snakeEnds.head.row - 1 < 0 ? gridSize - 1 : snakeEnds.head.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newHeadRow =\n          snakeEnds.head.row + 1 >= gridSize ? 0 : snakeEnds.head.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newHeadCol =\n          snakeEnds.head.col + 1 >= gridSize ? 0 : snakeEnds.head.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newHeadCol =\n          snakeEnds.head.col - 1 < 0 ? gridSize - 1 : snakeEnds.head.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid head direction!\");\n      }\n    }\n    ends.head.row = newHeadRow;\n    ends.head.col = newHeadCol;\n\n    // check if new Head is a valid role\n    switch (grid[newHeadRow][newHeadCol].role) {\n      case Role.Canvas: {\n        grid[newHeadRow][newHeadCol].role = Role.Head; // canvas -> head'\n        break;\n      }\n      case Role.Byte: {\n        console.log(\"Byte found!\");\n        break;\n      }\n      default:\n        setPlaying(false);\n        throw new Error(\"Head collision with invalid role\");\n    }\n\n    grid[newHeadRow][newHeadCol].direction = currentHeadDir; // retain previous head's dir in the new head\n  };\n\n  const calculateNewTail = (ends: typeof snakeEnds) => {\n    /* ========================= TAIL ==============================*/\n    const currentTailRow = snakeEnds.tail.row;\n    const currentTailCol = snakeEnds.tail.col;\n    const pivotDir = grid[currentTailRow][currentTailCol].pivot;\n    // override current tail direction if there is a pivot direction left behind by the head at some point.\n    const currentTailDir =\n      pivotDir !== Direction.None\n        ? pivotDir\n        : gridObj.getCurrentTailDirection();\n\n    grid[currentTailRow][currentTailCol].role = Role.Canvas; // tail -> canvas\n    grid[currentTailRow][currentTailCol].direction = Direction.None; // tail -> canvas dir\n\n    if (pivotDir !== Direction.None)\n      grid[currentTailRow][currentTailCol].pivot = Direction.None; // clear pivots as the tail arrives\n\n    let newTailRow = currentTailRow;\n    let newTailCol = currentTailCol;\n\n    // now calculate the new position (row, col) for tail based on the current tail direction.\n    switch (currentTailDir) {\n      case Direction.Up: {\n        newTailRow =\n          snakeEnds.tail.row - 1 < 0 ? gridSize - 1 : snakeEnds.tail.row - 1;\n        break;\n      }\n      case Direction.Down: {\n        newTailRow =\n          snakeEnds.tail.row + 1 >= gridSize ? 0 : snakeEnds.tail.row + 1;\n        break;\n      }\n      case Direction.Right: {\n        newTailCol =\n          snakeEnds.tail.col + 1 >= gridSize ? 0 : snakeEnds.tail.col + 1;\n        break;\n      }\n      case Direction.Left: {\n        newTailCol =\n          snakeEnds.tail.col - 1 < 0 ? gridSize - 1 : snakeEnds.tail.col - 1;\n        break;\n      }\n      default: {\n        setPlaying(false);\n        throw new Error(\"Invalid tail direction!\");\n      }\n    }\n\n    ends.tail.row = newTailRow;\n    ends.tail.col = newTailCol;\n    grid[newTailRow][newTailCol].role = Role.Tail; // body -> tail\n    grid[newTailRow][newTailCol].direction = currentTailDir;\n  };\n\n  // calcualte the new snake ends, and assign new roles as necessary\n  const getNewEnds = (ends: typeof snakeEnds) => {\n    calculateNewTail(ends);\n    calculateNewHead(ends);\n    return ends;\n  };\n\n  const onTick = () => {\n    let ends = { ...snakeEnds };\n    // set new roles on the new ends\n    const newEnds = getNewEnds(ends);\n    setSnakeEnds(newEnds);\n    // set new ends\n    gridObj.getSnake().setSnakeEnds(ends);\n  };\n\n  useInterval(\n    onTick,\n    // Delay in milliseconds or null to stop it\n    playing ? tickCountMs : null\n  );\n\n  const handleOnPlayPauseGame = useCallback(() => {\n    if (!playing) {\n      const currentTailDir = gridObj.getCurrentTailDirection();\n      const currentHeadDir = gridObj.getCurrentHeadDirection();\n      // on hitting play\n      if (\n        currentHeadDir === Direction.None &&\n        currentTailDir === Direction.None\n      ) {\n        gridObj.setCurrentTailDirection(Direction.Down);\n        gridObj.setCurrentHeadDirection(Direction.Down);\n      }\n    }\n\n    setPlaying((playing) => !playing);\n  }, [playing]);\n\n  const handleOnDebug = useCallback(() => {\n    setDebug((debug) => !debug);\n  }, []);\n\n  const isDebugMode = () => {\n    return urlSearchParams.get(\"debug\") === \"true\";\n  };\n\n  const handlers = useSwipeable({\n    onSwipedLeft: onSwipedLeft,\n    onSwipedRight: onSwipedRight,\n    onSwipedDown: onSwipedDown,\n    onSwipedUp: onSwipedUp,\n    // onTap: onTick,\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: true,\n  });\n\n  const currentTailPivot = gridObj.getPivotDirectionOnCurrentTail();\n\n  return (\n    <div {...handlers} className={\"game\"}>\n      <div className={\"gridContainer\"}>\n        {debug ? (\n          <DebugGrid grid={grid} />\n        ) : (\n          <GridRenderer\n            grid={grid}\n            currentHeadDirection={gridObj.getCurrentHeadDirection()}\n            currentTailDirection={gridObj.getCurrentTailDirection()}\n            currentTailPivot={currentTailPivot}\n          />\n        )}\n      </div>\n      <div className={\"appUtils\"}>\n        {\n          <Button\n            onClick={handleOnPlayPauseGame}\n            label={playing ? \"Pause\" : \"Play\"}\n          />\n        }\n        {isDebugMode() ? (\n          <Button\n            onClick={handleOnDebug}\n            label={debug ? \"Debug Off\" : \"Debug On\"}\n          />\n        ) : null}\n      </div>\n      <WordTiles />\n    </div>\n  );\n};\n","import { useEffect, useLayoutEffect, useRef } from \"react\"\n\nexport const useInterval = (callback: () => void, delay: number | null) => {\n    const savedCallback = useRef(callback)\n  \n    // Remember the latest callback if it changes.\n    useLayoutEffect(() => {\n      savedCallback.current = callback\n    }, [callback])\n  \n    // Set up the interval.\n    useEffect(() => {\n      // Don't schedule if no delay is specified.\n      if (!delay) {\n        return\n      }\n  \n      const id = setInterval(() => savedCallback.current(), delay)\n  \n      return () => clearInterval(id)\n    }, [delay])\n  }","import React from \"react\";\nimport \"./style/title.css\";\n\nexport const Title: React.FunctionComponent = () => {\n  return <div className=\"title\">Snake Bytes</div>;\n};\n","import React from \"react\";\nimport { Title } from \"./title\";\nimport \"./style/header.css\";\n\nexport const Header: React.FunctionComponent = () => {\n  return (\n    <div className={\"header\"}>\n      <div className={\"menuleft\"}>\n        <button className=\"About\" style={{ margin: \"2px\" }}>\n          {\"About\"}\n        </button>\n        <button className=\"Instructions\" style={{ margin: \"2px\" }}>\n          {\"How\"}\n        </button>\n      </div>\n      <Title />\n      <div className={\"menuright\"}>\n        <button className=\"Sett\" style={{ margin: \"2px\" }}>\n          {\"Settings\"}\n        </button>\n        <button className=\"Stat\" style={{ margin: \"2px\" }}>\n          {\"Stats\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./style/App.css\";\n\nimport { GridContainer } from \"./gridContainer\";\nimport { Header } from \"./header\";\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <div className={\"appContainer\"}>\n      <Header />\n      <GridContainer />\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/index.css\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}